{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Theoretical Basis: Projectile Motion 1. Motion of a Projectile When a projectile (such as a ball, bullet, or rocket) is launched at an angle to the horizontal, it follows a parabolic trajectory. This occurs due to two forces: The horizontal velocity remains constant (if we don't take air resistance). The vertical velocity changes due to gravity. Key Equations of Motion Horizontal coordinate (x): $$ x = v_0 \\cos(\\theta) t $$ where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is the time. Vertical coordinate (y): \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - \\(g\\) is the acceleration due to gravity (typically \\(9.81 \\text{ m/s}^2\\) ). and therefore our graph will be parabola and look like this: 2. Differential Equations with Air Resistance Modified equations (b = 0.1): When air resistance (drag force proportional to velocity) is included: Modified equations (b = 0.1): $$ m{x}'' = -b{x}' \\ $$ \\[ m{y}'' = -mg - b{y}' \\] First-order system: 1. Horizontal: $$ {x}' = v_x \\ $$ \\[ {v}_x' = {x}'' = -\\frac{b}{m}v_x \\] Vertical: $$ {y}' = v_y \\ $$ \\[ {v}_y' = {y}'' = -g - \\frac{b}{m}v_y \\] 3. Analytical Solution with Air Resistance When air resistance is considered, the equations of motion become more complex. The drag force opposes the motion and is typically proportional to the velocity (for low speeds). The analytical solutions for horizontal x(t) and vertical y(t) positions are: Horizontal position: \\[ x(t) = \\frac{v_0 \\cos(\\theta)} m b \\left(1 - e^{-\\frac{b}{m} t}\\right) \\] where: - \\(b\\) is the drag coefficient, - \\(m\\) is the mass of the projectile. Vertical position: \\[ y(t) = \\left(\\frac{v_0 \\sin(\\theta) m}{b} + \\frac{m^2 g}{b^2}\\right) \\left(1 - e^{-\\frac{b}{m} t}\\right) - \\frac{mg}{b} t \\] where: The horizontal motion is no longer linear due to the exponential decay term. The vertical motion includes a terminal velocity term ( \\(\\frac{mg}{b}\\) ) as \\(t \\to \\infty\\) . Trajectory Equation (y as function of x) By solving the x(t) equation for t and substituting into y(t), we get the trajectory equation: $$ y(x) = \\left(\\frac{mg}{b v_{0x}} + \\frac{v_{0y}}{v_{0x}}\\right)x + \\frac{m^2g}{b^2}\\ln\\left(1 - \\frac{b x}{m v_{0x}}\\right) $$ and now, with air resistance, our graph will look like this: 4. Python code for simulation Also, to better understand projectile motion, I wrote a Python script that simulates and visualizes the trajectory of our projectile. The script plots the parabolic path of a projectile based on different launch angles and initial velocities, which you can write by yourself. It uses the matplotlib and numpy libraries to generate the graphs. Here is the code: import numpy as np import matplotlib.pyplot as plt def calculate_trajectory(v0, angle, g=9.81, b=0.1, with_air=False): angle_rad = np.radians(angle) if not with_air: t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 else: def y_func(t): return (v0*np.sin(angle_rad) + g/b)*(1-np.exp(-b*t))/b - g*t/b t_flight = 0 dt = 0.01 while y_func(t_flight) >= 0: t_flight += dt t = np.linspace(0, t_flight, 100) x = (v0 * np.cos(angle_rad) * (1 - np.exp(-b*t))) / b y = y_func(t) return x, y v0 = float(input(\"Enter initial velocity (m/s): \")) angles = list(map(float, input(\"Enter angles (degrees, space-separated): \").split())) plt.figure(figsize=(10, 6)) for angle in angles: x, y = calculate_trajectory(v0, angle, with_air=False) plt.plot(x, y, label=f'{angle}\u00b0 (no air)') x_air, y_air = calculate_trajectory(v0, angle, with_air=True) plt.plot(x_air, y_air, '--', label=f'{angle}\u00b0 (with air)') plt.title(f'Projectile Trajectories (v0 = {v0} m/s)') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.axhline(0, color='black', linestyle='-', linewidth=0.5) plt.legend() plt.grid(True) plt.show() This code creates a graph that shows the trajectory of a projectile, with and without air resistance, when launched from different angles and with different initial speeds, you can enter these values \u200b\u200byourself. Also on this graph are 2 axes, distance and height, which show us exactly how high and far the projectile flew, here is the graph: and also one additional (opposite) python code where you write only one angle, but more than one starting velocity: import numpy as np import matplotlib.pyplot as plt def calculate_trajectory(v0, angle, g=9.81, b=0.1, with_air=False): angle_rad = np.radians(angle) if not with_air: t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 else: def y_func(t): return (v0*np.sin(angle_rad) + g/b)*(1-np.exp(-b*t))/b - g*t/b t_flight = 0 dt = 0.01 while y_func(t_flight) >= 0: t_flight += dt t = np.linspace(0, t_flight, 100) x = (v0 * np.cos(angle_rad) * (1 - np.exp(-b*t))) / b y = y_func(t) return x, y angle = float(input(\"Enter angle (degrees): \")) v0_list = list(map(float, input(\"Enter initial velocities (m/s, space-separated): \").split())) plt.figure(figsize=(10, 6)) for v0 in v0_list: x, y = calculate_trajectory(v0, angle, with_air=False) plt.plot(x, y, label=f'v0={v0} m/s (no air)') x_air, y_air = calculate_trajectory(v0, angle, with_air=True) plt.plot(x_air, y_air, '--', label=f'v0={v0} m/s (with air)') plt.title(f'Projectile Trajectories (angle = {angle}\u00b0)') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.axhline(0, color='black', linestyle='-', linewidth=0.5) plt.legend() plt.grid(True) plt.show() and here is the graph: 5. Brief description, how this code works This code simulates and plots projectile trajectories with and without air resistance. Here's a brief breakdown: 1.Function calculate_trajectory: Computes the x (horizontal) and y (vertical) positions of a projectile over time. Without air resistance: Uses basic kinematic equations for projectile motion. With air resistance: Uses more complex equations accounting for drag (exponential decay terms). Determines flight time differently for each case. 2.User Input: Takes initial velocity (v0) and multiple launch angles as input. 3.Plotting: For each angle, calculates and plots two trajectories: Solid line: No air resistance (ideal case) Dashed line: With air resistance (more realistic) Adds labels, grid, and other plot decorations. The key difference is that air resistance reduces the projectile's range and height, which is clearly visible in the plotted trajectories. The code allows comparison between ideal and air-resistant motion for multiple angles simultaneously. Google Colab Link (with Python code): MyColab","title":"Theoretical Basis: Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-basis-projectile-motion","text":"","title":"Theoretical Basis: Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motion-of-a-projectile","text":"When a projectile (such as a ball, bullet, or rocket) is launched at an angle to the horizontal, it follows a parabolic trajectory. This occurs due to two forces: The horizontal velocity remains constant (if we don't take air resistance). The vertical velocity changes due to gravity.","title":"1. Motion of a Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-equations-of-motion","text":"","title":"Key Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-coordinate-x","text":"$$ x = v_0 \\cos(\\theta) t $$ where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is the time.","title":"Horizontal coordinate (x):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-coordinate-y","text":"\\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - \\(g\\) is the acceleration due to gravity (typically \\(9.81 \\text{ m/s}^2\\) ). and therefore our graph will be parabola and look like this:","title":"Vertical coordinate (y):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-differential-equations-with-air-resistance","text":"Modified equations (b = 0.1): When air resistance (drag force proportional to velocity) is included: Modified equations (b = 0.1): $$ m{x}'' = -b{x}' \\ $$ \\[ m{y}'' = -mg - b{y}' \\] First-order system: 1. Horizontal: $$ {x}' = v_x \\ $$ \\[ {v}_x' = {x}'' = -\\frac{b}{m}v_x \\] Vertical: $$ {y}' = v_y \\ $$ \\[ {v}_y' = {y}'' = -g - \\frac{b}{m}v_y \\]","title":"2. Differential Equations with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analytical-solution-with-air-resistance","text":"When air resistance is considered, the equations of motion become more complex. The drag force opposes the motion and is typically proportional to the velocity (for low speeds). The analytical solutions for horizontal x(t) and vertical y(t) positions are:","title":"3. Analytical Solution with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-position","text":"\\[ x(t) = \\frac{v_0 \\cos(\\theta)} m b \\left(1 - e^{-\\frac{b}{m} t}\\right) \\] where: - \\(b\\) is the drag coefficient, - \\(m\\) is the mass of the projectile.","title":"Horizontal position:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-position","text":"\\[ y(t) = \\left(\\frac{v_0 \\sin(\\theta) m}{b} + \\frac{m^2 g}{b^2}\\right) \\left(1 - e^{-\\frac{b}{m} t}\\right) - \\frac{mg}{b} t \\] where: The horizontal motion is no longer linear due to the exponential decay term. The vertical motion includes a terminal velocity term ( \\(\\frac{mg}{b}\\) ) as \\(t \\to \\infty\\) .","title":"Vertical position:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation-y-as-function-of-x","text":"By solving the x(t) equation for t and substituting into y(t), we get the trajectory equation: $$ y(x) = \\left(\\frac{mg}{b v_{0x}} + \\frac{v_{0y}}{v_{0x}}\\right)x + \\frac{m^2g}{b^2}\\ln\\left(1 - \\frac{b x}{m v_{0x}}\\right) $$ and now, with air resistance, our graph will look like this:","title":"Trajectory Equation (y as function of x)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-code-for-simulation","text":"Also, to better understand projectile motion, I wrote a Python script that simulates and visualizes the trajectory of our projectile. The script plots the parabolic path of a projectile based on different launch angles and initial velocities, which you can write by yourself. It uses the matplotlib and numpy libraries to generate the graphs. Here is the code: import numpy as np import matplotlib.pyplot as plt def calculate_trajectory(v0, angle, g=9.81, b=0.1, with_air=False): angle_rad = np.radians(angle) if not with_air: t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 else: def y_func(t): return (v0*np.sin(angle_rad) + g/b)*(1-np.exp(-b*t))/b - g*t/b t_flight = 0 dt = 0.01 while y_func(t_flight) >= 0: t_flight += dt t = np.linspace(0, t_flight, 100) x = (v0 * np.cos(angle_rad) * (1 - np.exp(-b*t))) / b y = y_func(t) return x, y v0 = float(input(\"Enter initial velocity (m/s): \")) angles = list(map(float, input(\"Enter angles (degrees, space-separated): \").split())) plt.figure(figsize=(10, 6)) for angle in angles: x, y = calculate_trajectory(v0, angle, with_air=False) plt.plot(x, y, label=f'{angle}\u00b0 (no air)') x_air, y_air = calculate_trajectory(v0, angle, with_air=True) plt.plot(x_air, y_air, '--', label=f'{angle}\u00b0 (with air)') plt.title(f'Projectile Trajectories (v0 = {v0} m/s)') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.axhline(0, color='black', linestyle='-', linewidth=0.5) plt.legend() plt.grid(True) plt.show() This code creates a graph that shows the trajectory of a projectile, with and without air resistance, when launched from different angles and with different initial speeds, you can enter these values \u200b\u200byourself. Also on this graph are 2 axes, distance and height, which show us exactly how high and far the projectile flew, here is the graph: and also one additional (opposite) python code where you write only one angle, but more than one starting velocity: import numpy as np import matplotlib.pyplot as plt def calculate_trajectory(v0, angle, g=9.81, b=0.1, with_air=False): angle_rad = np.radians(angle) if not with_air: t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 else: def y_func(t): return (v0*np.sin(angle_rad) + g/b)*(1-np.exp(-b*t))/b - g*t/b t_flight = 0 dt = 0.01 while y_func(t_flight) >= 0: t_flight += dt t = np.linspace(0, t_flight, 100) x = (v0 * np.cos(angle_rad) * (1 - np.exp(-b*t))) / b y = y_func(t) return x, y angle = float(input(\"Enter angle (degrees): \")) v0_list = list(map(float, input(\"Enter initial velocities (m/s, space-separated): \").split())) plt.figure(figsize=(10, 6)) for v0 in v0_list: x, y = calculate_trajectory(v0, angle, with_air=False) plt.plot(x, y, label=f'v0={v0} m/s (no air)') x_air, y_air = calculate_trajectory(v0, angle, with_air=True) plt.plot(x_air, y_air, '--', label=f'v0={v0} m/s (with air)') plt.title(f'Projectile Trajectories (angle = {angle}\u00b0)') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.axhline(0, color='black', linestyle='-', linewidth=0.5) plt.legend() plt.grid(True) plt.show() and here is the graph:","title":"4. Python code for simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-brief-description-how-this-code-works","text":"This code simulates and plots projectile trajectories with and without air resistance. Here's a brief breakdown:","title":"5. Brief description, how this code works"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1function-calculate_trajectory","text":"Computes the x (horizontal) and y (vertical) positions of a projectile over time. Without air resistance: Uses basic kinematic equations for projectile motion. With air resistance: Uses more complex equations accounting for drag (exponential decay terms). Determines flight time differently for each case.","title":"1.Function calculate_trajectory:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2user-input","text":"Takes initial velocity (v0) and multiple launch angles as input.","title":"2.User Input:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3plotting","text":"For each angle, calculates and plots two trajectories: Solid line: No air resistance (ideal case) Dashed line: With air resistance (more realistic) Adds labels, grid, and other plot decorations. The key difference is that air resistance reduces the projectile's range and height, which is clearly visible in the plotted trajectories. The code allows comparison between ideal and air-resistant motion for multiple angles simultaneously.","title":"3.Plotting:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#google-colab-link-with-python-code","text":"MyColab","title":"Google Colab Link (with Python code):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation We start from the general second-order differential equation for a forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A\\cos(\\omega_{\\text{drive}} t) \\] where: \\(\\theta(t)\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0\\) = \\(\\sqrt{g/L}\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega_{\\text{drive}}\\) is the driving frequency. Small-Angle Approximation For small oscillations ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A\\cos(\\omega_{\\text{drive}} t) \\] This is now a linear second-order differential equation. Approximate Solution for Small Oscillations In steady state: \\[ \\theta(t) = \\theta_0 \\cos(\\omega_{\\text{drive}} t - \\delta) \\] Amplitude: \\[ \\theta_0 = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega_{\\text{drive}}^2)^2 + (b\\omega_{\\text{drive}})^2}} \\] Resonance Condition Resonance occurs at: \\[ \\omega_{\\text{drive}} \\approx \\sqrt{\\omega_0^2 - \\frac{b^2}{2}} \\] At resonance, small driving forces produce large oscillations. 2. Analysis of Dynamics Influence of Parameters Damping \\(b\\) reduces oscillation amplitudes and flattens resonance curves. Driving amplitude \\(A\\) increases overall energy input. Driving frequency \\(\\omega_{\\text{drive}}\\) controls resonance, synchronization, or chaos. Transition to Chaos For strong forcing and nonlinearity, pendulum exhibits chaotic behavior : No periodicity, Extreme sensitivity to initial conditions, Complex strange attractors. Here is the plot showing transition from regular to chaotic motion as A increases: 3. Practical Applications The forced damped pendulum model applies to: Energy harvesting (vibration-based generators), Suspension bridges (periodic forces from wind, pedestrians), Oscillating circuits (driven RLC circuits in electronics), Biomechanics (leg dynamics during walking/running). Here is an very simple example of real-world forced damped pendulum: 4. Implementation We simulate the forced damped pendulum numerically (using Runge-Kutta method). The equations: \\[ \\frac{d\\theta}{dt} = \\omega \\] \\[ \\frac{d\\omega}{dt} = -b\\omega - \\omega_0^2 \\sin(\\theta) + A\\cos(\\omega_{\\text{drive}}t) \\] 5. Simulations and Visualizations Simple Pendulum (No Damping, No Forcing) Damped Pendulum (Damping, No Forcing) Forced Pendulum (Forcing, No Damping) Forced Damped Pendulum (Chaos Examples) Scenario 1: Moderate damping and forcing Scenario 2: Strong forcing (possible resonance/chaos) Python Code for Simulations import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravity L = 1.0 # length omega0 = np.sqrt(g / L) # System of ODEs def pendulum(t, y, b, omega0, A, omega_drive): theta, omega = y dydt = [omega, -b*omega - omega0**2 * np.sin(theta) + A*np.cos(omega_drive*t)] return dydt # Simulation function def simulate_pendulum(b, A, omega_drive, y0=[0.2, 0.0], t_span=(0,100), num_points=5000): t_eval = np.linspace(t_span[0], t_span[1], num_points) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(b, omega0, A, omega_drive)) return sol.t, sol.y[0], sol.y[1] # Example of plotting def plot_simulation(b, A, omega_drive, title): t, theta, omega = simulate_pendulum(b, A, omega_drive) fig, axs = plt.subplots(1, 2, figsize=(12,5)) axs[0].plot(t, theta) axs[0].set_title('Angle vs Time') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(theta, omega) axs[1].set_title('Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') fig.suptitle(title) plt.tight_layout() plt.show() # Simulations plot_simulation(b=0.0, A=0.0, omega_drive=2/3, title='Simple Pendulum') plot_simulation(b=0.1, A=0.0, omega_drive=2/3, title='Damped Pendulum') plot_simulation(b=0.0, A=1.2, omega_drive=2/3, title='Forced Pendulum') plot_simulation(b=0.1, A=1.2, omega_drive=2/3, title='Forced Damped Pendulum - Moderate Chaos') plot_simulation(b=0.2, A=1.5, omega_drive=2/3, title='Forced Damped Pendulum - Strong Chaos') Deliverables Summary Full theoretical explanations Systematic graphical placeholders Full working Python code Real-world application discussion Preparation for detailed plotting: phase portraits, Poincar\u00e9 sections Google Colab Link (with Python code): MyColab","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"We start from the general second-order differential equation for a forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A\\cos(\\omega_{\\text{drive}} t) \\] where: \\(\\theta(t)\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0\\) = \\(\\sqrt{g/L}\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega_{\\text{drive}}\\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A\\cos(\\omega_{\\text{drive}} t) \\] This is now a linear second-order differential equation.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solution-for-small-oscillations","text":"In steady state: \\[ \\theta(t) = \\theta_0 \\cos(\\omega_{\\text{drive}} t - \\delta) \\] Amplitude: \\[ \\theta_0 = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega_{\\text{drive}}^2)^2 + (b\\omega_{\\text{drive}})^2}} \\]","title":"Approximate Solution for Small Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs at: \\[ \\omega_{\\text{drive}} \\approx \\sqrt{\\omega_0^2 - \\frac{b^2}{2}} \\] At resonance, small driving forces produce large oscillations.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-parameters","text":"Damping \\(b\\) reduces oscillation amplitudes and flattens resonance curves. Driving amplitude \\(A\\) increases overall energy input. Driving frequency \\(\\omega_{\\text{drive}}\\) controls resonance, synchronization, or chaos.","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"For strong forcing and nonlinearity, pendulum exhibits chaotic behavior : No periodicity, Extreme sensitivity to initial conditions, Complex strange attractors. Here is the plot showing transition from regular to chaotic motion as A increases:","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to: Energy harvesting (vibration-based generators), Suspension bridges (periodic forces from wind, pedestrians), Oscillating circuits (driven RLC circuits in electronics), Biomechanics (leg dynamics during walking/running). Here is an very simple example of real-world forced damped pendulum:","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We simulate the forced damped pendulum numerically (using Runge-Kutta method). The equations: \\[ \\frac{d\\theta}{dt} = \\omega \\] \\[ \\frac{d\\omega}{dt} = -b\\omega - \\omega_0^2 \\sin(\\theta) + A\\cos(\\omega_{\\text{drive}}t) \\]","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-simulations-and-visualizations","text":"","title":"5. Simulations and Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simple-pendulum-no-damping-no-forcing","text":"","title":"Simple Pendulum (No Damping, No Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damped-pendulum-damping-no-forcing","text":"","title":"Damped Pendulum (Damping, No Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-pendulum-forcing-no-damping","text":"","title":"Forced Pendulum (Forcing, No Damping)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-chaos-examples","text":"Scenario 1: Moderate damping and forcing Scenario 2: Strong forcing (possible resonance/chaos)","title":"Forced Damped Pendulum (Chaos Examples)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code-for-simulations","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravity L = 1.0 # length omega0 = np.sqrt(g / L) # System of ODEs def pendulum(t, y, b, omega0, A, omega_drive): theta, omega = y dydt = [omega, -b*omega - omega0**2 * np.sin(theta) + A*np.cos(omega_drive*t)] return dydt # Simulation function def simulate_pendulum(b, A, omega_drive, y0=[0.2, 0.0], t_span=(0,100), num_points=5000): t_eval = np.linspace(t_span[0], t_span[1], num_points) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(b, omega0, A, omega_drive)) return sol.t, sol.y[0], sol.y[1] # Example of plotting def plot_simulation(b, A, omega_drive, title): t, theta, omega = simulate_pendulum(b, A, omega_drive) fig, axs = plt.subplots(1, 2, figsize=(12,5)) axs[0].plot(t, theta) axs[0].set_title('Angle vs Time') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(theta, omega) axs[1].set_title('Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') fig.suptitle(title) plt.tight_layout() plt.show() # Simulations plot_simulation(b=0.0, A=0.0, omega_drive=2/3, title='Simple Pendulum') plot_simulation(b=0.1, A=0.0, omega_drive=2/3, title='Damped Pendulum') plot_simulation(b=0.0, A=1.2, omega_drive=2/3, title='Forced Pendulum') plot_simulation(b=0.1, A=1.2, omega_drive=2/3, title='Forced Damped Pendulum - Moderate Chaos') plot_simulation(b=0.2, A=1.5, omega_drive=2/3, title='Forced Damped Pendulum - Strong Chaos')","title":"Python Code for Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables-summary","text":"Full theoretical explanations Systematic graphical placeholders Full working Python code Real-world application discussion Preparation for detailed plotting: phase portraits, Poincar\u00e9 sections","title":"Deliverables Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#google-colab-link-with-python-code","text":"MyColab","title":"Google Colab Link (with Python code):"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Gravity Orbital Period and Orbital Radius 1. Derivation of the \\(T^2 \\propto r^3\\) Kepler Formula First, let's define: \\(T\\) is the orbital period, the time it takes for a body (like a planet) to complete one full orbit around a central mass (like the Sun). We start with Newton's Law of Universal Gravitation and circular motion concepts. Gravitational force provides the necessary centripetal force for a planet in a circular orbit: \\(F_{\\text{gravity}} = F_{\\text{centripetal}}\\) \\(\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\) Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., the Sun), - \\(m\\) is the mass of the orbiting object (e.g., a planet), - \\(r\\) is the orbital radius, - \\(v\\) is the orbital speed. Simplify: \\(GM = rv^2\\) Orbital period \\(T\\) is the time for one full orbit: \\(T = \\frac{2\\pi r}{v} \\quad \\text{thus} \\quad v = \\frac{2\\pi r}{T}\\) Substitute \\(v\\) back: \\(GM = r \\left(\\frac{2\\pi r}{T}\\right)^2\\) \\(GM = r \\cdot \\frac{4\\pi^2 r^2}{T^2}\\) \\(GM = \\frac{4\\pi^2 r^3}{T^2}\\) Now solving for \\(T^2\\) : \\(T^2 = \\frac{4\\pi^2}{GM} r^3\\) This is Kepler\u2019s Third Law for circular orbits: \ud83d\udd38 \\(T^2 \\propto r^3\\) 2. Verification: Use Mercury, Venus, Earth, Mars Let's use real Solar System data: Planet Orbital Radius \\(r\\) (in \\(10^6\\) km) Orbital Period \\(T\\) (in Earth years) Mercury 57.9 0.241 Venus 108.2 0.615 Earth 149.6 1.000 Mars 227.9 1.881 Now we compute: \\(r^3\\) \\(T^2\\) Planet \\(r^3\\) (in \\(10^{18}\\) km\u00b3) \\(T^2\\) (in years\u00b2) Mercury 194.1 0.058 Venus 1267.4 0.378 Earth 3348.4 1.000 Mars 11841.0 3.538 and now new we must plot \\(T^2\\) versus \\(r^3\\) and show that it gives a straight line : 3. Find Mass of the Earth and Sun using Kepler's Law From Kepler\u2019s formula: \\(T^2 = \\frac{4\\pi^2}{GM} r^3 \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2}\\) For Earth orbiting the Sun: Given: - \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) - \\(T = 365.25 \\times 24 \\times 3600 = 31,557,600 \\, \\text{seconds}\\) - \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) Substituting: \\(M_{\\text{sun}} = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11})(31,557,600)^2}\\) You get: \\(M_{\\text{sun}} \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) \u2705 Matches known Sun mass! Similarly, for the Moon orbiting Earth: \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\times 24 \\times 3600 = 2,360,448 \\, \\text{seconds}\\) \\(M_{\\text{earth}} = \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.67430 \\times 10^{-11})(2,360,448)^2}\\) You get: \\(M_{\\text{earth}} \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) \u2705 Matches Earth mass! Python Code to Simulate and Plot import numpy as np import matplotlib.pyplot as plt import pandas as pd planets = { 'Mercury': {'r': 57.9e6, 'T': 0.241}, 'Venus': {'r': 108.2e6, 'T': 0.615}, 'Earth': {'r': 149.6e6, 'T': 1.000}, 'Mars': {'r': 227.9e6, 'T': 1.881} } data = { 'Planet': [], 'r (10^6 km)': [], 'T (years)': [], 'r\u00b3 (10^18 km\u00b3)': [], 'T\u00b2 (years\u00b2)': [] } for name, values in planets.items(): r = values['r'] T = values['T'] data['Planet'].append(name) data['r (10^6 km)'].append(r) data['T (years)'].append(T) data['r\u00b3 (10^18 km\u00b3)'].append((r**3) / 1e18) data['T\u00b2 (years\u00b2)'].append(T**2) df = pd.DataFrame(data) print(df) plt.plot(df['r\u00b3 (10^18 km\u00b3)'], df['T\u00b2 (years\u00b2)'], 'ro-', markersize=8) for i, txt in enumerate(df['Planet']): plt.annotate(txt, (df['r\u00b3 (10^18 km\u00b3)'][i], df['T\u00b2 (years\u00b2)'][i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel(r'$r^3$ (in $10^{18}\\ km^3$)') plt.ylabel(r'$T^2$ (in $years^2$)') plt.title('Verification of Kepler\\'s Third Law with Solar System Planets') plt.grid(True) plt.show() Additional Discussion: Elliptical Orbits In elliptical orbits, Kepler\u2019s Third Law still holds , but \\(r\\) is replaced by the semi-major axis \\(a\\) . The formula becomes: \\(T^2 = \\frac{4\\pi^2}{GM} a^3\\) So even for comets or highly elliptical paths, this law connects time and distance! Google Colab Link (with Python code): MyColab","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity","text":"","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-t2-propto-r3-kepler-formula","text":"First, let's define: \\(T\\) is the orbital period, the time it takes for a body (like a planet) to complete one full orbit around a central mass (like the Sun). We start with Newton's Law of Universal Gravitation and circular motion concepts. Gravitational force provides the necessary centripetal force for a planet in a circular orbit: \\(F_{\\text{gravity}} = F_{\\text{centripetal}}\\) \\(\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\) Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., the Sun), - \\(m\\) is the mass of the orbiting object (e.g., a planet), - \\(r\\) is the orbital radius, - \\(v\\) is the orbital speed. Simplify: \\(GM = rv^2\\) Orbital period \\(T\\) is the time for one full orbit: \\(T = \\frac{2\\pi r}{v} \\quad \\text{thus} \\quad v = \\frac{2\\pi r}{T}\\) Substitute \\(v\\) back: \\(GM = r \\left(\\frac{2\\pi r}{T}\\right)^2\\) \\(GM = r \\cdot \\frac{4\\pi^2 r^2}{T^2}\\) \\(GM = \\frac{4\\pi^2 r^3}{T^2}\\) Now solving for \\(T^2\\) : \\(T^2 = \\frac{4\\pi^2}{GM} r^3\\) This is Kepler\u2019s Third Law for circular orbits: \ud83d\udd38 \\(T^2 \\propto r^3\\)","title":"1. Derivation of the \\(T^2 \\propto r^3\\) Kepler Formula"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-verification-use-mercury-venus-earth-mars","text":"Let's use real Solar System data: Planet Orbital Radius \\(r\\) (in \\(10^6\\) km) Orbital Period \\(T\\) (in Earth years) Mercury 57.9 0.241 Venus 108.2 0.615 Earth 149.6 1.000 Mars 227.9 1.881 Now we compute: \\(r^3\\) \\(T^2\\) Planet \\(r^3\\) (in \\(10^{18}\\) km\u00b3) \\(T^2\\) (in years\u00b2) Mercury 194.1 0.058 Venus 1267.4 0.378 Earth 3348.4 1.000 Mars 11841.0 3.538 and now new we must plot \\(T^2\\) versus \\(r^3\\) and show that it gives a straight line :","title":"2. Verification: Use Mercury, Venus, Earth, Mars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-find-mass-of-the-earth-and-sun-using-keplers-law","text":"From Kepler\u2019s formula: \\(T^2 = \\frac{4\\pi^2}{GM} r^3 \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2}\\) For Earth orbiting the Sun: Given: - \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) - \\(T = 365.25 \\times 24 \\times 3600 = 31,557,600 \\, \\text{seconds}\\) - \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) Substituting: \\(M_{\\text{sun}} = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11})(31,557,600)^2}\\) You get: \\(M_{\\text{sun}} \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) \u2705 Matches known Sun mass! Similarly, for the Moon orbiting Earth: \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\times 24 \\times 3600 = 2,360,448 \\, \\text{seconds}\\) \\(M_{\\text{earth}} = \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.67430 \\times 10^{-11})(2,360,448)^2}\\) You get: \\(M_{\\text{earth}} \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) \u2705 Matches Earth mass!","title":"3. Find Mass of the Earth and Sun using Kepler's Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-to-simulate-and-plot","text":"import numpy as np import matplotlib.pyplot as plt import pandas as pd planets = { 'Mercury': {'r': 57.9e6, 'T': 0.241}, 'Venus': {'r': 108.2e6, 'T': 0.615}, 'Earth': {'r': 149.6e6, 'T': 1.000}, 'Mars': {'r': 227.9e6, 'T': 1.881} } data = { 'Planet': [], 'r (10^6 km)': [], 'T (years)': [], 'r\u00b3 (10^18 km\u00b3)': [], 'T\u00b2 (years\u00b2)': [] } for name, values in planets.items(): r = values['r'] T = values['T'] data['Planet'].append(name) data['r (10^6 km)'].append(r) data['T (years)'].append(T) data['r\u00b3 (10^18 km\u00b3)'].append((r**3) / 1e18) data['T\u00b2 (years\u00b2)'].append(T**2) df = pd.DataFrame(data) print(df) plt.plot(df['r\u00b3 (10^18 km\u00b3)'], df['T\u00b2 (years\u00b2)'], 'ro-', markersize=8) for i, txt in enumerate(df['Planet']): plt.annotate(txt, (df['r\u00b3 (10^18 km\u00b3)'][i], df['T\u00b2 (years\u00b2)'][i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel(r'$r^3$ (in $10^{18}\\ km^3$)') plt.ylabel(r'$T^2$ (in $years^2$)') plt.title('Verification of Kepler\\'s Third Law with Solar System Planets') plt.grid(True) plt.show()","title":"Python Code to Simulate and Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/#additional-discussion-elliptical-orbits","text":"In elliptical orbits, Kepler\u2019s Third Law still holds , but \\(r\\) is replaced by the semi-major axis \\(a\\) . The formula becomes: \\(T^2 = \\frac{4\\pi^2}{GM} a^3\\) So even for comets or highly elliptical paths, this law connects time and distance!","title":"Additional Discussion: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#google-colab-link-with-python-code","text":"MyColab","title":"Google Colab Link (with Python code):"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"GRAVITY PROBLEM 2: Escape Velocities and Cosmic Velocities Definitions and Physical Meaning First Cosmic Velocity (Orbital Velocity) Minimum speed to enter a circular orbit near the surface of a planet, without propulsion. Second Cosmic Velocity (Escape Velocity) Minimum speed to completely overcome the planet\u2019s gravitational field without further propulsion. Third Cosmic Velocity (Interplanetary Escape Velocity) Minimum speed needed to escape the gravitational field of the Sun starting from the orbit around the planet. Mathematical Derivations 1. First Cosmic Velocity Derivation (v\u2081) An object in a circular orbit experiences gravitational force as the centripetal force: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] where: - $ G $ = gravitational constant - $ M $ = mass of the planet - $ m $ = mass of the object - $ R $ = radius of the planet - $ v_1 $ = first cosmic velocity Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Velocity vs Planet Radius for first cosmic velocity: 2. Second Cosmic Velocity Derivation (v\u2082) The object needs kinetic energy to match the gravitational potential energy: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Notice that: \\[ v_2 = \\sqrt{2} \\times v_1 \\] Relationship between first and second cosmic velocities: 3. Third Cosmic Velocity Derivation (v\u2083) To escape from the Sun's gravity starting from orbit around Earth: - First, object must reach Earth escape velocity ( \\(v_2\\) ) - Then, it must have enough additional velocity to escape the Sun\u2019s gravitational field. Approximate derivation: \\[ v_3 \\approx \\sqrt{v_{e,Sun}^2 - v_{orb,Earth}^2} \\] where: - \\(v_{e,Sun}\\) = escape velocity from Sun at Earth's orbit - \\(v_{orb,Earth}\\) = Earth's orbital speed around the Sun More precisely: Since Earth moves around the Sun, the spacecraft needs to cancel Earth\u2019s orbital motion and then escape. Also here is the escape trajectory from solar orbit: Values for Earth Quantity Value Mass $ M_{\\text{Earth}} $ $ 5.972 \\times 10^{24} \\, \\text{kg} $ Radius $ R_{\\text{Earth}} $ $ 6.371 \\times 10^6 \\, \\text{m} $ Gravitational Constant $ G $ $ 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $ Calculating: \\[ v_1 = \\sqrt{\\frac{6.67430 \\times 10^{-11} \\times 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.9 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2} \\times v_1 \\approx 11.2 \\, \\text{km/s} \\] $$ v_3 \\approx 16.7 \\, \\text{km/s} $$ Visual/Data Comparison: Earth vs Moon, Mars, Jupiter Celestial Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) (approximate) Earth 7.9 11.2 16.7 Moon 1.68 2.38 - (Moon orbiting Earth) Mars 3.55 5.03 ~14.1 Jupiter 42.1 59.5 ~18.5 And here is the comparison of cosmic velocities for Earth, Moon, Mars, and Jupiter: and also python graph: Graphical Representation Comparison of Cosmic Velocities: import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot plt.figure(figsize=(10, 6)) plt.bar(x, v1, width=0.25, label='First Cosmic Velocity (v1)', align='center') plt.bar([i + 0.25 for i in x], v2, width=0.25, label='Second Cosmic Velocity (v2)', align='center') plt.bar([i + 0.5 for i in x], [v if v else 0 for v in v3], width=0.25, label='Third Cosmic Velocity (v3)', align='center') plt.xticks([i + 0.25 for i in x], bodies) plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() Velocity vs Planet Radius for first cosmic velocity python code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth in kg (we'll keep it constant for this graph) # Generate a range of planet radii (in meters) radii = np.linspace(1e6, 1.5e7, 500) # from 1000 km to 15000 km # Calculate first cosmic velocity for each radius v1 = np.sqrt(G * M / radii) # Convert velocity to km/s v1_km_s = v1 / 1000 # Plotting plt.figure(figsize=(10,6)) plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='blue') # radii in km plt.xlabel('Planet Radius (km)') plt.ylabel('First Cosmic Velocity (km/s)') plt.title('First Cosmic Velocity vs Planet Radius') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show() Relationship between first and second cosmic velocities: import numpy as np import matplotlib.pyplot as plt # Define a range of first cosmic velocities (v1) in km/s v1 = np.linspace(0, 20, 500) # Calculate second cosmic velocities (v2) v2 = np.sqrt(2) * v1 # Plotting plt.figure(figsize=(10,6)) plt.plot(v1, v2, label=r'$v_2 = \\sqrt{2} \\times v_1$', color='green') plt.plot(v1, v1, linestyle='--', color='gray', label=r'$v_2 = v_1$ (reference line)') plt.xlabel('First Cosmic Velocity $v_1$ (km/s)') plt.ylabel('Second Cosmic Velocity $v_2$ (km/s)') plt.title('Relationship between First and Second Cosmic Velocities') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show() Importance in Space Exploration First Cosmic Velocity: Satellites in low Earth orbit (e.g., ISS). Second Cosmic Velocity: Interplanetary missions (e.g., Apollo to the Moon). Third Cosmic Velocity: Interstellar probes (e.g., Voyager missions leaving the Solar System). Understanding these velocities allows mission designers to optimize launch profiles and minimize fuel usage, which is crucial for cost-effective space exploration. Google Colab Link (with Python code): MyColab","title":"GRAVITY PROBLEM 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravity-problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"GRAVITY PROBLEM 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meaning","text":"First Cosmic Velocity (Orbital Velocity) Minimum speed to enter a circular orbit near the surface of a planet, without propulsion. Second Cosmic Velocity (Escape Velocity) Minimum speed to completely overcome the planet\u2019s gravitational field without further propulsion. Third Cosmic Velocity (Interplanetary Escape Velocity) Minimum speed needed to escape the gravitational field of the Sun starting from the orbit around the planet.","title":"Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-derivation-v1","text":"An object in a circular orbit experiences gravitational force as the centripetal force: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] where: - $ G $ = gravitational constant - $ M $ = mass of the planet - $ m $ = mass of the object - $ R $ = radius of the planet - $ v_1 $ = first cosmic velocity Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Velocity vs Planet Radius for first cosmic velocity:","title":"1. First Cosmic Velocity Derivation (v\u2081)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-derivation-v2","text":"The object needs kinetic energy to match the gravitational potential energy: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Notice that: \\[ v_2 = \\sqrt{2} \\times v_1 \\] Relationship between first and second cosmic velocities:","title":"2. Second Cosmic Velocity Derivation (v\u2082)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-derivation-v3","text":"To escape from the Sun's gravity starting from orbit around Earth: - First, object must reach Earth escape velocity ( \\(v_2\\) ) - Then, it must have enough additional velocity to escape the Sun\u2019s gravitational field. Approximate derivation: \\[ v_3 \\approx \\sqrt{v_{e,Sun}^2 - v_{orb,Earth}^2} \\] where: - \\(v_{e,Sun}\\) = escape velocity from Sun at Earth's orbit - \\(v_{orb,Earth}\\) = Earth's orbital speed around the Sun More precisely: Since Earth moves around the Sun, the spacecraft needs to cancel Earth\u2019s orbital motion and then escape. Also here is the escape trajectory from solar orbit:","title":"3. Third Cosmic Velocity Derivation (v\u2083)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#values-for-earth","text":"Quantity Value Mass $ M_{\\text{Earth}} $ $ 5.972 \\times 10^{24} \\, \\text{kg} $ Radius $ R_{\\text{Earth}} $ $ 6.371 \\times 10^6 \\, \\text{m} $ Gravitational Constant $ G $ $ 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $ Calculating: \\[ v_1 = \\sqrt{\\frac{6.67430 \\times 10^{-11} \\times 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.9 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2} \\times v_1 \\approx 11.2 \\, \\text{km/s} \\]","title":"Values for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#v_3-approx-167-textkms","text":"","title":"$$ v_3 \\approx 16.7 \\, \\text{km/s} $$"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualdata-comparison-earth-vs-moon-mars-jupiter","text":"Celestial Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) (approximate) Earth 7.9 11.2 16.7 Moon 1.68 2.38 - (Moon orbiting Earth) Mars 3.55 5.03 ~14.1 Jupiter 42.1 59.5 ~18.5 And here is the comparison of cosmic velocities for Earth, Moon, Mars, and Jupiter: and also python graph:","title":"Visual/Data Comparison: Earth vs Moon, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"Comparison of Cosmic Velocities: import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot plt.figure(figsize=(10, 6)) plt.bar(x, v1, width=0.25, label='First Cosmic Velocity (v1)', align='center') plt.bar([i + 0.25 for i in x], v2, width=0.25, label='Second Cosmic Velocity (v2)', align='center') plt.bar([i + 0.5 for i in x], [v if v else 0 for v in v3], width=0.25, label='Third Cosmic Velocity (v3)', align='center') plt.xticks([i + 0.25 for i in x], bodies) plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() Velocity vs Planet Radius for first cosmic velocity python code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth in kg (we'll keep it constant for this graph) # Generate a range of planet radii (in meters) radii = np.linspace(1e6, 1.5e7, 500) # from 1000 km to 15000 km # Calculate first cosmic velocity for each radius v1 = np.sqrt(G * M / radii) # Convert velocity to km/s v1_km_s = v1 / 1000 # Plotting plt.figure(figsize=(10,6)) plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='blue') # radii in km plt.xlabel('Planet Radius (km)') plt.ylabel('First Cosmic Velocity (km/s)') plt.title('First Cosmic Velocity vs Planet Radius') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show() Relationship between first and second cosmic velocities: import numpy as np import matplotlib.pyplot as plt # Define a range of first cosmic velocities (v1) in km/s v1 = np.linspace(0, 20, 500) # Calculate second cosmic velocities (v2) v2 = np.sqrt(2) * v1 # Plotting plt.figure(figsize=(10,6)) plt.plot(v1, v2, label=r'$v_2 = \\sqrt{2} \\times v_1$', color='green') plt.plot(v1, v1, linestyle='--', color='gray', label=r'$v_2 = v_1$ (reference line)') plt.xlabel('First Cosmic Velocity $v_1$ (km/s)') plt.ylabel('Second Cosmic Velocity $v_2$ (km/s)') plt.title('Relationship between First and Second Cosmic Velocities') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show()","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity: Satellites in low Earth orbit (e.g., ISS). Second Cosmic Velocity: Interplanetary missions (e.g., Apollo to the Moon). Third Cosmic Velocity: Interstellar probes (e.g., Voyager missions leaving the Solar System). Understanding these velocities allows mission designers to optimize launch profiles and minimize fuel usage, which is crucial for cost-effective space exploration.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#google-colab-link-with-python-code","text":"MyColab","title":"Google Colab Link (with Python code):"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}