{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Theoretical Basis: Projectile Motion 1. Motion of a Projectile When a projectile (such as a ball, bullet, or rocket) is launched at an angle to the horizontal, it follows a parabolic trajectory. This occurs due to two forces: The horizontal velocity remains constant (if we don't take air resistance). The vertical velocity changes due to gravity. Key Equations of Motion Horizontal coordinate (x): $$ x = v_0 \\cos(\\theta) t $$ where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is the time. Vertical coordinate (y): \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - \\(g\\) is the acceleration due to gravity (typically \\(9.81 \\text{ m/s}^2\\) ). and therefore our graph will be parabola and look like this: 2. Differential Equations with Air Resistance Modified equations (b = 0.1): When air resistance (drag force proportional to velocity) is included: Modified equations (b = 0.1): $$ m{x}'' = -b{x}' \\ $$ \\[ m{y}'' = -mg - b{y}' \\] First-order system: 1. Horizontal: $$ {x}' = v_x \\ $$ \\[ {v}_x' = {x}'' = -\\frac{b}{m}v_x \\] Vertical: $$ {y}' = v_y \\ $$ \\[ {v}_y' = {y}'' = -g - \\frac{b}{m}v_y \\] 3. Analytical Solution with Air Resistance When air resistance is considered, the equations of motion become more complex. The drag force opposes the motion and is typically proportional to the velocity (for low speeds). The analytical solutions for horizontal x(t) and vertical y(t) positions are: Horizontal position: \\[ x(t) = \\frac{v_0 \\cos(\\theta)} m b \\left(1 - e^{-\\frac{b}{m} t}\\right) \\] where: - \\(b\\) is the drag coefficient, - \\(m\\) is the mass of the projectile. Vertical position: \\[ y(t) = \\left(\\frac{v_0 \\sin(\\theta) m}{b} + \\frac{m^2 g}{b^2}\\right) \\left(1 - e^{-\\frac{b}{m} t}\\right) - \\frac{mg}{b} t \\] where: The horizontal motion is no longer linear due to the exponential decay term. The vertical motion includes a terminal velocity term ( \\(\\frac{mg}{b}\\) ) as \\(t \\to \\infty\\) . Trajectory Equation (y as function of x) By solving the x(t) equation for t and substituting into y(t), we get the trajectory equation: $$ y(x) = \\left(\\frac{mg}{b v_{0x}} + \\frac{v_{0y}}{v_{0x}}\\right)x + \\frac{m^2g}{b^2}\\ln\\left(1 - \\frac{b x}{m v_{0x}}\\right) $$ and now, with air resistance, our graph will look like this: 4. Python code for simulation Also, to better understand projectile motion, I wrote a Python script that simulates and visualizes the trajectory of our projectile. The script plots the parabolic path of a projectile based on different launch angles and initial velocities, which you can write by yourself. It uses the matplotlib and numpy libraries to generate the graphs. Here is the code: import numpy as np import matplotlib.pyplot as plt def calculate_trajectory(v0, angle, g=9.81, b=0.1, with_air=False): angle_rad = np.radians(angle) if not with_air: t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 else: def y_func(t): return (v0*np.sin(angle_rad) + g/b)*(1-np.exp(-b*t))/b - g*t/b t_flight = 0 dt = 0.01 while y_func(t_flight) >= 0: t_flight += dt t = np.linspace(0, t_flight, 100) x = (v0 * np.cos(angle_rad) * (1 - np.exp(-b*t))) / b y = y_func(t) return x, y v0 = float(input(\"Enter initial velocity (m/s): \")) angles = list(map(float, input(\"Enter angles (degrees, space-separated): \").split())) plt.figure(figsize=(10, 6)) for angle in angles: x, y = calculate_trajectory(v0, angle, with_air=False) plt.plot(x, y, label=f'{angle}\u00b0 (no air)') x_air, y_air = calculate_trajectory(v0, angle, with_air=True) plt.plot(x_air, y_air, '--', label=f'{angle}\u00b0 (with air)') plt.title(f'Projectile Trajectories (v0 = {v0} m/s)') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.axhline(0, color='black', linestyle='-', linewidth=0.5) plt.legend() plt.grid(True) plt.show() This code creates a graph that shows the trajectory of a projectile, with and without air resistance, when launched from different angles and with different initial speeds, you can enter these values \u200b\u200byourself. Also on this graph are 2 axes, distance and height, which show us exactly how high and far the projectile flew, here is the graph: and also one additional (opposite) python code where you write only one angle, but more than one starting velocity: import numpy as np import matplotlib.pyplot as plt def calculate_trajectory(v0, angle, g=9.81, b=0.1, with_air=False): angle_rad = np.radians(angle) if not with_air: t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 else: def y_func(t): return (v0*np.sin(angle_rad) + g/b)*(1-np.exp(-b*t))/b - g*t/b t_flight = 0 dt = 0.01 while y_func(t_flight) >= 0: t_flight += dt t = np.linspace(0, t_flight, 100) x = (v0 * np.cos(angle_rad) * (1 - np.exp(-b*t))) / b y = y_func(t) return x, y angle = float(input(\"Enter angle (degrees): \")) v0_list = list(map(float, input(\"Enter initial velocities (m/s, space-separated): \").split())) plt.figure(figsize=(10, 6)) for v0 in v0_list: x, y = calculate_trajectory(v0, angle, with_air=False) plt.plot(x, y, label=f'v0={v0} m/s (no air)') x_air, y_air = calculate_trajectory(v0, angle, with_air=True) plt.plot(x_air, y_air, '--', label=f'v0={v0} m/s (with air)') plt.title(f'Projectile Trajectories (angle = {angle}\u00b0)') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.axhline(0, color='black', linestyle='-', linewidth=0.5) plt.legend() plt.grid(True) plt.show() and here is the graph: 5. Brief description, how this code works This code simulates and plots projectile trajectories with and without air resistance. Here's a brief breakdown: 1.Function calculate_trajectory: Computes the x (horizontal) and y (vertical) positions of a projectile over time. Without air resistance: Uses basic kinematic equations for projectile motion. With air resistance: Uses more complex equations accounting for drag (exponential decay terms). Determines flight time differently for each case. 2.User Input: Takes initial velocity (v0) and multiple launch angles as input. 3.Plotting: For each angle, calculates and plots two trajectories: Solid line: No air resistance (ideal case) Dashed line: With air resistance (more realistic) Adds labels, grid, and other plot decorations. The key difference is that air resistance reduces the projectile's range and height, which is clearly visible in the plotted trajectories. The code allows comparison between ideal and air-resistant motion for multiple angles simultaneously. Google Colab Link (with Python code): MyColab","title":"Theoretical Basis: Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-basis-projectile-motion","text":"","title":"Theoretical Basis: Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motion-of-a-projectile","text":"When a projectile (such as a ball, bullet, or rocket) is launched at an angle to the horizontal, it follows a parabolic trajectory. This occurs due to two forces: The horizontal velocity remains constant (if we don't take air resistance). The vertical velocity changes due to gravity.","title":"1. Motion of a Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-equations-of-motion","text":"","title":"Key Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-coordinate-x","text":"$$ x = v_0 \\cos(\\theta) t $$ where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is the time.","title":"Horizontal coordinate (x):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-coordinate-y","text":"\\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - \\(g\\) is the acceleration due to gravity (typically \\(9.81 \\text{ m/s}^2\\) ). and therefore our graph will be parabola and look like this:","title":"Vertical coordinate (y):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-differential-equations-with-air-resistance","text":"Modified equations (b = 0.1): When air resistance (drag force proportional to velocity) is included: Modified equations (b = 0.1): $$ m{x}'' = -b{x}' \\ $$ \\[ m{y}'' = -mg - b{y}' \\] First-order system: 1. Horizontal: $$ {x}' = v_x \\ $$ \\[ {v}_x' = {x}'' = -\\frac{b}{m}v_x \\] Vertical: $$ {y}' = v_y \\ $$ \\[ {v}_y' = {y}'' = -g - \\frac{b}{m}v_y \\]","title":"2. Differential Equations with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analytical-solution-with-air-resistance","text":"When air resistance is considered, the equations of motion become more complex. The drag force opposes the motion and is typically proportional to the velocity (for low speeds). The analytical solutions for horizontal x(t) and vertical y(t) positions are:","title":"3. Analytical Solution with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-position","text":"\\[ x(t) = \\frac{v_0 \\cos(\\theta)} m b \\left(1 - e^{-\\frac{b}{m} t}\\right) \\] where: - \\(b\\) is the drag coefficient, - \\(m\\) is the mass of the projectile.","title":"Horizontal position:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-position","text":"\\[ y(t) = \\left(\\frac{v_0 \\sin(\\theta) m}{b} + \\frac{m^2 g}{b^2}\\right) \\left(1 - e^{-\\frac{b}{m} t}\\right) - \\frac{mg}{b} t \\] where: The horizontal motion is no longer linear due to the exponential decay term. The vertical motion includes a terminal velocity term ( \\(\\frac{mg}{b}\\) ) as \\(t \\to \\infty\\) .","title":"Vertical position:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#trajectory-equation-y-as-function-of-x","text":"By solving the x(t) equation for t and substituting into y(t), we get the trajectory equation: $$ y(x) = \\left(\\frac{mg}{b v_{0x}} + \\frac{v_{0y}}{v_{0x}}\\right)x + \\frac{m^2g}{b^2}\\ln\\left(1 - \\frac{b x}{m v_{0x}}\\right) $$ and now, with air resistance, our graph will look like this:","title":"Trajectory Equation (y as function of x)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-code-for-simulation","text":"Also, to better understand projectile motion, I wrote a Python script that simulates and visualizes the trajectory of our projectile. The script plots the parabolic path of a projectile based on different launch angles and initial velocities, which you can write by yourself. It uses the matplotlib and numpy libraries to generate the graphs. Here is the code: import numpy as np import matplotlib.pyplot as plt def calculate_trajectory(v0, angle, g=9.81, b=0.1, with_air=False): angle_rad = np.radians(angle) if not with_air: t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 else: def y_func(t): return (v0*np.sin(angle_rad) + g/b)*(1-np.exp(-b*t))/b - g*t/b t_flight = 0 dt = 0.01 while y_func(t_flight) >= 0: t_flight += dt t = np.linspace(0, t_flight, 100) x = (v0 * np.cos(angle_rad) * (1 - np.exp(-b*t))) / b y = y_func(t) return x, y v0 = float(input(\"Enter initial velocity (m/s): \")) angles = list(map(float, input(\"Enter angles (degrees, space-separated): \").split())) plt.figure(figsize=(10, 6)) for angle in angles: x, y = calculate_trajectory(v0, angle, with_air=False) plt.plot(x, y, label=f'{angle}\u00b0 (no air)') x_air, y_air = calculate_trajectory(v0, angle, with_air=True) plt.plot(x_air, y_air, '--', label=f'{angle}\u00b0 (with air)') plt.title(f'Projectile Trajectories (v0 = {v0} m/s)') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.axhline(0, color='black', linestyle='-', linewidth=0.5) plt.legend() plt.grid(True) plt.show() This code creates a graph that shows the trajectory of a projectile, with and without air resistance, when launched from different angles and with different initial speeds, you can enter these values \u200b\u200byourself. Also on this graph are 2 axes, distance and height, which show us exactly how high and far the projectile flew, here is the graph: and also one additional (opposite) python code where you write only one angle, but more than one starting velocity: import numpy as np import matplotlib.pyplot as plt def calculate_trajectory(v0, angle, g=9.81, b=0.1, with_air=False): angle_rad = np.radians(angle) if not with_air: t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 else: def y_func(t): return (v0*np.sin(angle_rad) + g/b)*(1-np.exp(-b*t))/b - g*t/b t_flight = 0 dt = 0.01 while y_func(t_flight) >= 0: t_flight += dt t = np.linspace(0, t_flight, 100) x = (v0 * np.cos(angle_rad) * (1 - np.exp(-b*t))) / b y = y_func(t) return x, y angle = float(input(\"Enter angle (degrees): \")) v0_list = list(map(float, input(\"Enter initial velocities (m/s, space-separated): \").split())) plt.figure(figsize=(10, 6)) for v0 in v0_list: x, y = calculate_trajectory(v0, angle, with_air=False) plt.plot(x, y, label=f'v0={v0} m/s (no air)') x_air, y_air = calculate_trajectory(v0, angle, with_air=True) plt.plot(x_air, y_air, '--', label=f'v0={v0} m/s (with air)') plt.title(f'Projectile Trajectories (angle = {angle}\u00b0)') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.axhline(0, color='black', linestyle='-', linewidth=0.5) plt.legend() plt.grid(True) plt.show() and here is the graph:","title":"4. Python code for simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-brief-description-how-this-code-works","text":"This code simulates and plots projectile trajectories with and without air resistance. Here's a brief breakdown:","title":"5. Brief description, how this code works"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1function-calculate_trajectory","text":"Computes the x (horizontal) and y (vertical) positions of a projectile over time. Without air resistance: Uses basic kinematic equations for projectile motion. With air resistance: Uses more complex equations accounting for drag (exponential decay terms). Determines flight time differently for each case.","title":"1.Function calculate_trajectory:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2user-input","text":"Takes initial velocity (v0) and multiple launch angles as input.","title":"2.User Input:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3plotting","text":"For each angle, calculates and plots two trajectories: Solid line: No air resistance (ideal case) Dashed line: With air resistance (more realistic) Adds labels, grid, and other plot decorations. The key difference is that air resistance reduces the projectile's range and height, which is clearly visible in the plotted trajectories. The code allows comparison between ideal and air-resistant motion for multiple angles simultaneously.","title":"3.Plotting:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#google-colab-link-with-python-code","text":"MyColab","title":"Google Colab Link (with Python code):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation We start from the general second-order differential equation for a forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A\\cos(\\omega_{\\text{drive}} t) \\] where: \\(\\theta(t)\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0\\) = \\(\\sqrt{g/L}\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega_{\\text{drive}}\\) is the driving frequency. Small-Angle Approximation For small oscillations ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A\\cos(\\omega_{\\text{drive}} t) \\] This is now a linear second-order differential equation. Approximate Solution for Small Oscillations In steady state: \\[ \\theta(t) = \\theta_0 \\cos(\\omega_{\\text{drive}} t - \\delta) \\] Amplitude: \\[ \\theta_0 = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega_{\\text{drive}}^2)^2 + (b\\omega_{\\text{drive}})^2}} \\] Resonance Condition Resonance occurs at: \\[ \\omega_{\\text{drive}} \\approx \\sqrt{\\omega_0^2 - \\frac{b^2}{2}} \\] At resonance, small driving forces produce large oscillations. 2. Analysis of Dynamics Influence of Parameters Damping \\(b\\) reduces oscillation amplitudes and flattens resonance curves. Driving amplitude \\(A\\) increases overall energy input. Driving frequency \\(\\omega_{\\text{drive}}\\) controls resonance, synchronization, or chaos. Transition to Chaos For strong forcing and nonlinearity, pendulum exhibits chaotic behavior : No periodicity, Extreme sensitivity to initial conditions, Complex strange attractors. Here is the plot showing transition from regular to chaotic motion as A increases: 3. Practical Applications The forced damped pendulum model applies to: Energy harvesting (vibration-based generators), Suspension bridges (periodic forces from wind, pedestrians), Oscillating circuits (driven RLC circuits in electronics), Biomechanics (leg dynamics during walking/running). Here is an very simple example of real-world forced damped pendulum: 4. Implementation We simulate the forced damped pendulum numerically (using Runge-Kutta method). The equations: \\[ \\frac{d\\theta}{dt} = \\omega \\] \\[ \\frac{d\\omega}{dt} = -b\\omega - \\omega_0^2 \\sin(\\theta) + A\\cos(\\omega_{\\text{drive}}t) \\] 5. Simulations and Visualizations Simple Pendulum (No Damping, No Forcing) Damped Pendulum (Damping, No Forcing) Forced Pendulum (Forcing, No Damping) Forced Damped Pendulum (Chaos Examples) Scenario 1: Moderate damping and forcing Scenario 2: Strong forcing (possible resonance/chaos) Python Code for Simulations import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravity L = 1.0 # length omega0 = np.sqrt(g / L) # System of ODEs def pendulum(t, y, b, omega0, A, omega_drive): theta, omega = y dydt = [omega, -b*omega - omega0**2 * np.sin(theta) + A*np.cos(omega_drive*t)] return dydt # Simulation function def simulate_pendulum(b, A, omega_drive, y0=[0.2, 0.0], t_span=(0,100), num_points=5000): t_eval = np.linspace(t_span[0], t_span[1], num_points) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(b, omega0, A, omega_drive)) return sol.t, sol.y[0], sol.y[1] # Example of plotting def plot_simulation(b, A, omega_drive, title): t, theta, omega = simulate_pendulum(b, A, omega_drive) fig, axs = plt.subplots(1, 2, figsize=(12,5)) axs[0].plot(t, theta) axs[0].set_title('Angle vs Time') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(theta, omega) axs[1].set_title('Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') fig.suptitle(title) plt.tight_layout() plt.show() # Simulations plot_simulation(b=0.0, A=0.0, omega_drive=2/3, title='Simple Pendulum') plot_simulation(b=0.1, A=0.0, omega_drive=2/3, title='Damped Pendulum') plot_simulation(b=0.0, A=1.2, omega_drive=2/3, title='Forced Pendulum') plot_simulation(b=0.1, A=1.2, omega_drive=2/3, title='Forced Damped Pendulum - Moderate Chaos') plot_simulation(b=0.2, A=1.5, omega_drive=2/3, title='Forced Damped Pendulum - Strong Chaos') Deliverables Summary Full theoretical explanations Systematic graphical placeholders Full working Python code Real-world application discussion Preparation for detailed plotting: phase portraits, Poincar\u00e9 sections Google Colab Link (with Python code): MyColab","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"We start from the general second-order differential equation for a forced damped pendulum: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A\\cos(\\omega_{\\text{drive}} t) \\] where: \\(\\theta(t)\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0\\) = \\(\\sqrt{g/L}\\) ), \\(A\\) is the amplitude of the external driving force, \\(\\omega_{\\text{drive}}\\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A\\cos(\\omega_{\\text{drive}} t) \\] This is now a linear second-order differential equation.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solution-for-small-oscillations","text":"In steady state: \\[ \\theta(t) = \\theta_0 \\cos(\\omega_{\\text{drive}} t - \\delta) \\] Amplitude: \\[ \\theta_0 = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega_{\\text{drive}}^2)^2 + (b\\omega_{\\text{drive}})^2}} \\]","title":"Approximate Solution for Small Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs at: \\[ \\omega_{\\text{drive}} \\approx \\sqrt{\\omega_0^2 - \\frac{b^2}{2}} \\] At resonance, small driving forces produce large oscillations.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-parameters","text":"Damping \\(b\\) reduces oscillation amplitudes and flattens resonance curves. Driving amplitude \\(A\\) increases overall energy input. Driving frequency \\(\\omega_{\\text{drive}}\\) controls resonance, synchronization, or chaos.","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"For strong forcing and nonlinearity, pendulum exhibits chaotic behavior : No periodicity, Extreme sensitivity to initial conditions, Complex strange attractors. Here is the plot showing transition from regular to chaotic motion as A increases:","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to: Energy harvesting (vibration-based generators), Suspension bridges (periodic forces from wind, pedestrians), Oscillating circuits (driven RLC circuits in electronics), Biomechanics (leg dynamics during walking/running). Here is an very simple example of real-world forced damped pendulum:","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We simulate the forced damped pendulum numerically (using Runge-Kutta method). The equations: \\[ \\frac{d\\theta}{dt} = \\omega \\] \\[ \\frac{d\\omega}{dt} = -b\\omega - \\omega_0^2 \\sin(\\theta) + A\\cos(\\omega_{\\text{drive}}t) \\]","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-simulations-and-visualizations","text":"","title":"5. Simulations and Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simple-pendulum-no-damping-no-forcing","text":"","title":"Simple Pendulum (No Damping, No Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damped-pendulum-damping-no-forcing","text":"","title":"Damped Pendulum (Damping, No Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-pendulum-forcing-no-damping","text":"","title":"Forced Pendulum (Forcing, No Damping)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-chaos-examples","text":"Scenario 1: Moderate damping and forcing Scenario 2: Strong forcing (possible resonance/chaos)","title":"Forced Damped Pendulum (Chaos Examples)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code-for-simulations","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # gravity L = 1.0 # length omega0 = np.sqrt(g / L) # System of ODEs def pendulum(t, y, b, omega0, A, omega_drive): theta, omega = y dydt = [omega, -b*omega - omega0**2 * np.sin(theta) + A*np.cos(omega_drive*t)] return dydt # Simulation function def simulate_pendulum(b, A, omega_drive, y0=[0.2, 0.0], t_span=(0,100), num_points=5000): t_eval = np.linspace(t_span[0], t_span[1], num_points) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(b, omega0, A, omega_drive)) return sol.t, sol.y[0], sol.y[1] # Example of plotting def plot_simulation(b, A, omega_drive, title): t, theta, omega = simulate_pendulum(b, A, omega_drive) fig, axs = plt.subplots(1, 2, figsize=(12,5)) axs[0].plot(t, theta) axs[0].set_title('Angle vs Time') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(theta, omega) axs[1].set_title('Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') fig.suptitle(title) plt.tight_layout() plt.show() # Simulations plot_simulation(b=0.0, A=0.0, omega_drive=2/3, title='Simple Pendulum') plot_simulation(b=0.1, A=0.0, omega_drive=2/3, title='Damped Pendulum') plot_simulation(b=0.0, A=1.2, omega_drive=2/3, title='Forced Pendulum') plot_simulation(b=0.1, A=1.2, omega_drive=2/3, title='Forced Damped Pendulum - Moderate Chaos') plot_simulation(b=0.2, A=1.5, omega_drive=2/3, title='Forced Damped Pendulum - Strong Chaos')","title":"Python Code for Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables-summary","text":"Full theoretical explanations Systematic graphical placeholders Full working Python code Real-world application discussion Preparation for detailed plotting: phase portraits, Poincar\u00e9 sections","title":"Deliverables Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#google-colab-link-with-python-code","text":"MyColab","title":"Google Colab Link (with Python code):"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"1\ufe0f\u20e3 Gravity Orbital Period and Orbital Radius 1. Derivation of the \\(T^2 \\propto r^3\\) Kepler Formula First, let's define: \\(T\\) is the orbital period, the time it takes for a body (like a planet) to complete one full orbit around a central mass (like the Sun). We start with Newton's Law of Universal Gravitation and circular motion concepts. Gravitational force provides the necessary centripetal force for a planet in a circular orbit: \\(F_{\\text{gravity}} = F_{\\text{centripetal}}\\) \\(\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\) Where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the central body (e.g., the Sun), - \\(m\\) is the mass of the orbiting object (e.g., a planet), - \\(r\\) is the orbital radius, - \\(v\\) is the orbital speed. Simplify: \\(GM = rv^2\\) Orbital period \\(T\\) is the time for one full orbit: \\(T = \\frac{2\\pi r}{v} \\quad \\text{thus} \\quad v = \\frac{2\\pi r}{T}\\) Substitute \\(v\\) back: \\(GM = r \\left(\\frac{2\\pi r}{T}\\right)^2\\) \\(GM = r \\cdot \\frac{4\\pi^2 r^2}{T^2}\\) \\(GM = \\frac{4\\pi^2 r^3}{T^2}\\) Now solving for \\(T^2\\) : \\(T^2 = \\frac{4\\pi^2}{GM} r^3\\) This is Kepler\u2019s Third Law for circular orbits: \ud83d\udd38 \\(T^2 \\propto r^3\\) 2. Verification: Use Mercury, Venus, Earth, Mars Let's use real Solar System data: Planet Orbital Radius \\(r\\) (in \\(10^6\\) km) Orbital Period \\(T\\) (in Earth years) Mercury 57.9 0.241 Venus 108.2 0.615 Earth 149.6 1.000 Mars 227.9 1.881 Now we compute: \\(r^3\\) \\(T^2\\) Planet \\(r^3\\) (in \\(10^{18}\\) km\u00b3) \\(T^2\\) (in years\u00b2) Mercury 194.1 0.058 Venus 1267.4 0.378 Earth 3348.4 1.000 Mars 11841.0 3.538 and now new we must plot \\(T^2\\) versus \\(r^3\\) and show that it gives a straight line : 3. Find Mass of the Earth and Sun using Kepler's Law From Kepler\u2019s formula: \\(T^2 = \\frac{4\\pi^2}{GM} r^3 \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2}\\) For Earth orbiting the Sun: Given: - \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) - \\(T = 365.25 \\times 24 \\times 3600 = 31,557,600 \\, \\text{seconds}\\) - \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) Substituting: \\(M_{\\text{sun}} = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11})(31,557,600)^2}\\) You get: \\(M_{\\text{sun}} \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) \u2705 Matches known Sun mass! Similarly, for the Moon orbiting Earth: \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\times 24 \\times 3600 = 2,360,448 \\, \\text{seconds}\\) \\(M_{\\text{earth}} = \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.67430 \\times 10^{-11})(2,360,448)^2}\\) You get: \\(M_{\\text{earth}} \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) \u2705 Matches Earth mass! Python Code to Simulate and Plot import numpy as np import matplotlib.pyplot as plt import pandas as pd planets = { 'Mercury': {'r': 57.9e6, 'T': 0.241}, 'Venus': {'r': 108.2e6, 'T': 0.615}, 'Earth': {'r': 149.6e6, 'T': 1.000}, 'Mars': {'r': 227.9e6, 'T': 1.881} } data = { 'Planet': [], 'r (10^6 km)': [], 'T (years)': [], 'r\u00b3 (10^18 km\u00b3)': [], 'T\u00b2 (years\u00b2)': [] } for name, values in planets.items(): r = values['r'] T = values['T'] data['Planet'].append(name) data['r (10^6 km)'].append(r) data['T (years)'].append(T) data['r\u00b3 (10^18 km\u00b3)'].append((r**3) / 1e18) data['T\u00b2 (years\u00b2)'].append(T**2) df = pd.DataFrame(data) print(df) plt.plot(df['r\u00b3 (10^18 km\u00b3)'], df['T\u00b2 (years\u00b2)'], 'ro-', markersize=8) for i, txt in enumerate(df['Planet']): plt.annotate(txt, (df['r\u00b3 (10^18 km\u00b3)'][i], df['T\u00b2 (years\u00b2)'][i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel(r'$r^3$ (in $10^{18}\\ km^3$)') plt.ylabel(r'$T^2$ (in $years^2$)') plt.title('Verification of Kepler\\'s Third Law with Solar System Planets') plt.grid(True) plt.show() Additional Discussion: Elliptical Orbits In elliptical orbits, Kepler\u2019s Third Law still holds , but \\(r\\) is replaced by the semi-major axis \\(a\\) . The formula becomes: \\(T^2 = \\frac{4\\pi^2}{GM} a^3\\) So even for comets or highly elliptical paths, this law connects time and distance! Google Colab Link (with Python code): MyColab","title":"1\ufe0f\u20e3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1","text":"","title":"1\ufe0f\u20e3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity","text":"","title":"Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-t2-propto-r3-kepler-formula","text":"First, let's define: \\(T\\) is the orbital period, the time it takes for a body (like a planet) to complete one full orbit around a central mass (like the Sun). We start with Newton's Law of Universal Gravitation and circular motion concepts. Gravitational force provides the necessary centripetal force for a planet in a circular orbit: \\(F_{\\text{gravity}} = F_{\\text{centripetal}}\\) \\(\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\) Where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the central body (e.g., the Sun), - \\(m\\) is the mass of the orbiting object (e.g., a planet), - \\(r\\) is the orbital radius, - \\(v\\) is the orbital speed. Simplify: \\(GM = rv^2\\) Orbital period \\(T\\) is the time for one full orbit: \\(T = \\frac{2\\pi r}{v} \\quad \\text{thus} \\quad v = \\frac{2\\pi r}{T}\\) Substitute \\(v\\) back: \\(GM = r \\left(\\frac{2\\pi r}{T}\\right)^2\\) \\(GM = r \\cdot \\frac{4\\pi^2 r^2}{T^2}\\) \\(GM = \\frac{4\\pi^2 r^3}{T^2}\\) Now solving for \\(T^2\\) : \\(T^2 = \\frac{4\\pi^2}{GM} r^3\\) This is Kepler\u2019s Third Law for circular orbits: \ud83d\udd38 \\(T^2 \\propto r^3\\)","title":"1. Derivation of the \\(T^2 \\propto r^3\\) Kepler Formula"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-verification-use-mercury-venus-earth-mars","text":"Let's use real Solar System data: Planet Orbital Radius \\(r\\) (in \\(10^6\\) km) Orbital Period \\(T\\) (in Earth years) Mercury 57.9 0.241 Venus 108.2 0.615 Earth 149.6 1.000 Mars 227.9 1.881 Now we compute: \\(r^3\\) \\(T^2\\) Planet \\(r^3\\) (in \\(10^{18}\\) km\u00b3) \\(T^2\\) (in years\u00b2) Mercury 194.1 0.058 Venus 1267.4 0.378 Earth 3348.4 1.000 Mars 11841.0 3.538 and now new we must plot \\(T^2\\) versus \\(r^3\\) and show that it gives a straight line :","title":"2. Verification: Use Mercury, Venus, Earth, Mars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-find-mass-of-the-earth-and-sun-using-keplers-law","text":"From Kepler\u2019s formula: \\(T^2 = \\frac{4\\pi^2}{GM} r^3 \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2}\\) For Earth orbiting the Sun: Given: - \\(r = 1.496 \\times 10^{11} \\, \\text{m}\\) - \\(T = 365.25 \\times 24 \\times 3600 = 31,557,600 \\, \\text{seconds}\\) - \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) Substituting: \\(M_{\\text{sun}} = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11})(31,557,600)^2}\\) You get: \\(M_{\\text{sun}} \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) \u2705 Matches known Sun mass! Similarly, for the Moon orbiting Earth: \\(r = 3.844 \\times 10^8 \\, \\text{m}\\) \\(T = 27.32 \\times 24 \\times 3600 = 2,360,448 \\, \\text{seconds}\\) \\(M_{\\text{earth}} = \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{(6.67430 \\times 10^{-11})(2,360,448)^2}\\) You get: \\(M_{\\text{earth}} \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) \u2705 Matches Earth mass!","title":"3. Find Mass of the Earth and Sun using Kepler's Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-to-simulate-and-plot","text":"import numpy as np import matplotlib.pyplot as plt import pandas as pd planets = { 'Mercury': {'r': 57.9e6, 'T': 0.241}, 'Venus': {'r': 108.2e6, 'T': 0.615}, 'Earth': {'r': 149.6e6, 'T': 1.000}, 'Mars': {'r': 227.9e6, 'T': 1.881} } data = { 'Planet': [], 'r (10^6 km)': [], 'T (years)': [], 'r\u00b3 (10^18 km\u00b3)': [], 'T\u00b2 (years\u00b2)': [] } for name, values in planets.items(): r = values['r'] T = values['T'] data['Planet'].append(name) data['r (10^6 km)'].append(r) data['T (years)'].append(T) data['r\u00b3 (10^18 km\u00b3)'].append((r**3) / 1e18) data['T\u00b2 (years\u00b2)'].append(T**2) df = pd.DataFrame(data) print(df) plt.plot(df['r\u00b3 (10^18 km\u00b3)'], df['T\u00b2 (years\u00b2)'], 'ro-', markersize=8) for i, txt in enumerate(df['Planet']): plt.annotate(txt, (df['r\u00b3 (10^18 km\u00b3)'][i], df['T\u00b2 (years\u00b2)'][i]), textcoords=\"offset points\", xytext=(5,5), ha='center') plt.xlabel(r'$r^3$ (in $10^{18}\\ km^3$)') plt.ylabel(r'$T^2$ (in $years^2$)') plt.title('Verification of Kepler\\'s Third Law with Solar System Planets') plt.grid(True) plt.show()","title":"Python Code to Simulate and Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/#additional-discussion-elliptical-orbits","text":"In elliptical orbits, Kepler\u2019s Third Law still holds , but \\(r\\) is replaced by the semi-major axis \\(a\\) . The formula becomes: \\(T^2 = \\frac{4\\pi^2}{GM} a^3\\) So even for comets or highly elliptical paths, this law connects time and distance!","title":"Additional Discussion: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#google-colab-link-with-python-code","text":"MyColab","title":"Google Colab Link (with Python code):"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"2\ufe0f\u20e3 GRAVITY PROBLEM 2: Escape Velocities and Cosmic Velocities Definitions and Physical Meaning First Cosmic Velocity (Orbital Velocity) Minimum speed to enter a circular orbit near the surface of a planet, without propulsion. Second Cosmic Velocity (Escape Velocity) Minimum speed to completely overcome the planet\u2019s gravitational field without further propulsion. Third Cosmic Velocity (Interplanetary Escape Velocity) Minimum speed needed to escape the gravitational field of the Sun starting from the orbit around the planet. Mathematical Derivations 1. First Cosmic Velocity Derivation (v\u2081) An object in a circular orbit experiences gravitational force as the centripetal force: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] where: \\(G\\) gravitational constant, \\(M\\) mass of the planet, \\(m\\) mass of the object, \\(R\\) radius of the planet, \\(v_1\\) first cosmic velocity. Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Velocity vs Planet Radius for first cosmic velocity: 2. Second Cosmic Velocity Derivation (v\u2082) The object needs kinetic energy to match the gravitational potential energy: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Notice that: \\[ v_2 = \\sqrt{2} \\times v_1 \\] Relationship between first and second cosmic velocities: 3. Third Cosmic Velocity Derivation (v\u2083) To escape from the Sun's gravity starting from orbit around Earth: - First, object must reach Earth escape velocity ( \\(v_2\\) ) - Then, it must have enough additional velocity to escape the Sun\u2019s gravitational field. Approximate derivation: \\[ v_3 \\approx \\sqrt{v_{e,Sun}^2 - v_{orb,Earth}^2} \\] where: - \\(v_{e,Sun}\\) = escape velocity from Sun at Earth's orbit - \\(v_{orb,Earth}\\) = Earth's orbital speed around the Sun More precisely: Since Earth moves around the Sun, the spacecraft needs to cancel Earth\u2019s orbital motion and then escape. Also here is the escape trajectory from solar orbit: Values for Earth Quantity Value Mass \\(M_{\\text{Earth}}\\) \\(5.972 \\times 10^{24} \\, \\text{kg}\\) Radius \\(R_{\\text{Earth}}\\) \\(6.371 \\times 10^6 \\, \\text{m}\\) Gravitational Constant \\(G\\) \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) Calculating: \\[ v_1 = \\sqrt{\\frac{6.67430 \\times 10^{-11} \\times 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.9 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2} \\times v_1 \\approx 11.2 \\, \\text{km/s} \\] $$ v_3 \\approx 16.7 \\, \\text{km/s} $$ Visual/Data Comparison: Earth vs Moon, Mars, Jupiter Celestial Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) (approximate) Earth 7.9 11.2 16.7 Moon 1.68 2.38 - (Moon orbiting Earth) Mars 3.55 5.03 ~14.1 Jupiter 42.1 59.5 ~18.5 And here is the comparison of cosmic velocities for Earth, Moon, Mars, and Jupiter: and also python graph: Graphical Representation Comparison of Cosmic Velocities: import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot plt.figure(figsize=(10, 6)) plt.bar(x, v1, width=0.25, label='First Cosmic Velocity (v1)', align='center') plt.bar([i + 0.25 for i in x], v2, width=0.25, label='Second Cosmic Velocity (v2)', align='center') plt.bar([i + 0.5 for i in x], [v if v else 0 for v in v3], width=0.25, label='Third Cosmic Velocity (v3)', align='center') plt.xticks([i + 0.25 for i in x], bodies) plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() Velocity vs Planet Radius for first cosmic velocity python code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth in kg (we'll keep it constant for this graph) # Generate a range of planet radii (in meters) radii = np.linspace(1e6, 1.5e7, 500) # from 1000 km to 15000 km # Calculate first cosmic velocity for each radius v1 = np.sqrt(G * M / radii) # Convert velocity to km/s v1_km_s = v1 / 1000 # Plotting plt.figure(figsize=(10,6)) plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='blue') # radii in km plt.xlabel('Planet Radius (km)') plt.ylabel('First Cosmic Velocity (km/s)') plt.title('First Cosmic Velocity vs Planet Radius') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show() Relationship between first and second cosmic velocities: import numpy as np import matplotlib.pyplot as plt # Define a range of first cosmic velocities (v1) in km/s v1 = np.linspace(0, 20, 500) # Calculate second cosmic velocities (v2) v2 = np.sqrt(2) * v1 # Plotting plt.figure(figsize=(10,6)) plt.plot(v1, v2, label=r'$v_2 = \\sqrt{2} \\times v_1$', color='green') plt.plot(v1, v1, linestyle='--', color='gray', label=r'$v_2 = v_1$ (reference line)') plt.xlabel('First Cosmic Velocity $v_1$ (km/s)') plt.ylabel('Second Cosmic Velocity $v_2$ (km/s)') plt.title('Relationship between First and Second Cosmic Velocities') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show() Importance in Space Exploration First Cosmic Velocity: Satellites in low Earth orbit (e.g., ISS). Second Cosmic Velocity: Interplanetary missions (e.g., Apollo to the Moon). Third Cosmic Velocity: Interstellar probes (e.g., Voyager missions leaving the Solar System). Understanding these velocities allows mission designers to optimize launch profiles and minimize fuel usage, which is crucial for cost-effective space exploration. Google Colab Link (with Python code): MyColab","title":"2\ufe0f\u20e3"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2","text":"","title":"2\ufe0f\u20e3"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravity-problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"GRAVITY PROBLEM 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meaning","text":"First Cosmic Velocity (Orbital Velocity) Minimum speed to enter a circular orbit near the surface of a planet, without propulsion. Second Cosmic Velocity (Escape Velocity) Minimum speed to completely overcome the planet\u2019s gravitational field without further propulsion. Third Cosmic Velocity (Interplanetary Escape Velocity) Minimum speed needed to escape the gravitational field of the Sun starting from the orbit around the planet.","title":"Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-derivation-v1","text":"An object in a circular orbit experiences gravitational force as the centripetal force: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] where: \\(G\\) gravitational constant, \\(M\\) mass of the planet, \\(m\\) mass of the object, \\(R\\) radius of the planet, \\(v_1\\) first cosmic velocity. Solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Velocity vs Planet Radius for first cosmic velocity:","title":"1. First Cosmic Velocity Derivation (v\u2081)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-derivation-v2","text":"The object needs kinetic energy to match the gravitational potential energy: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Notice that: \\[ v_2 = \\sqrt{2} \\times v_1 \\] Relationship between first and second cosmic velocities:","title":"2. Second Cosmic Velocity Derivation (v\u2082)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-derivation-v3","text":"To escape from the Sun's gravity starting from orbit around Earth: - First, object must reach Earth escape velocity ( \\(v_2\\) ) - Then, it must have enough additional velocity to escape the Sun\u2019s gravitational field. Approximate derivation: \\[ v_3 \\approx \\sqrt{v_{e,Sun}^2 - v_{orb,Earth}^2} \\] where: - \\(v_{e,Sun}\\) = escape velocity from Sun at Earth's orbit - \\(v_{orb,Earth}\\) = Earth's orbital speed around the Sun More precisely: Since Earth moves around the Sun, the spacecraft needs to cancel Earth\u2019s orbital motion and then escape. Also here is the escape trajectory from solar orbit:","title":"3. Third Cosmic Velocity Derivation (v\u2083)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#values-for-earth","text":"Quantity Value Mass \\(M_{\\text{Earth}}\\) \\(5.972 \\times 10^{24} \\, \\text{kg}\\) Radius \\(R_{\\text{Earth}}\\) \\(6.371 \\times 10^6 \\, \\text{m}\\) Gravitational Constant \\(G\\) \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) Calculating: \\[ v_1 = \\sqrt{\\frac{6.67430 \\times 10^{-11} \\times 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.9 \\, \\text{km/s} \\] \\[ v_2 = \\sqrt{2} \\times v_1 \\approx 11.2 \\, \\text{km/s} \\]","title":"Values for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#v_3-approx-167-textkms","text":"","title":"$$ v_3 \\approx 16.7 \\, \\text{km/s} $$"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualdata-comparison-earth-vs-moon-mars-jupiter","text":"Celestial Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) (approximate) Earth 7.9 11.2 16.7 Moon 1.68 2.38 - (Moon orbiting Earth) Mars 3.55 5.03 ~14.1 Jupiter 42.1 59.5 ~18.5 And here is the comparison of cosmic velocities for Earth, Moon, Mars, and Jupiter: and also python graph:","title":"Visual/Data Comparison: Earth vs Moon, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"Comparison of Cosmic Velocities: import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot plt.figure(figsize=(10, 6)) plt.bar(x, v1, width=0.25, label='First Cosmic Velocity (v1)', align='center') plt.bar([i + 0.25 for i in x], v2, width=0.25, label='Second Cosmic Velocity (v2)', align='center') plt.bar([i + 0.5 for i in x], [v if v else 0 for v in v3], width=0.25, label='Third Cosmic Velocity (v3)', align='center') plt.xticks([i + 0.25 for i in x], bodies) plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() Velocity vs Planet Radius for first cosmic velocity python code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # mass of Earth in kg (we'll keep it constant for this graph) # Generate a range of planet radii (in meters) radii = np.linspace(1e6, 1.5e7, 500) # from 1000 km to 15000 km # Calculate first cosmic velocity for each radius v1 = np.sqrt(G * M / radii) # Convert velocity to km/s v1_km_s = v1 / 1000 # Plotting plt.figure(figsize=(10,6)) plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='blue') # radii in km plt.xlabel('Planet Radius (km)') plt.ylabel('First Cosmic Velocity (km/s)') plt.title('First Cosmic Velocity vs Planet Radius') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show() Relationship between first and second cosmic velocities: import numpy as np import matplotlib.pyplot as plt # Define a range of first cosmic velocities (v1) in km/s v1 = np.linspace(0, 20, 500) # Calculate second cosmic velocities (v2) v2 = np.sqrt(2) * v1 # Plotting plt.figure(figsize=(10,6)) plt.plot(v1, v2, label=r'$v_2 = \\sqrt{2} \\times v_1$', color='green') plt.plot(v1, v1, linestyle='--', color='gray', label=r'$v_2 = v_1$ (reference line)') plt.xlabel('First Cosmic Velocity $v_1$ (km/s)') plt.ylabel('Second Cosmic Velocity $v_2$ (km/s)') plt.title('Relationship between First and Second Cosmic Velocities') plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.show()","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity: Satellites in low Earth orbit (e.g., ISS). Second Cosmic Velocity: Interplanetary missions (e.g., Apollo to the Moon). Third Cosmic Velocity: Interstellar probes (e.g., Voyager missions leaving the Solar System). Understanding these velocities allows mission designers to optimize launch profiles and minimize fuel usage, which is crucial for cost-effective space exploration.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#google-colab-link-with-python-code","text":"MyColab","title":"Google Colab Link (with Python code):"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"3\ufe0f Trajectories of a Freely Released Payload Near Earth 1. Objective Analyze and simulate the trajectories of a payload released from a certain height (800 km above Earth's surface) with various initial horizontal velocities. Determine whether the resulting path is elliptical, parabolic, or hyperbolic , and relate these outcomes to space mission concepts like orbital insertion, reentry, or escape velocity . 2. Physical Background We analyze the motion under Newton\u2019s Law of Universal Gravitation : \\[ \\vec{F}_g = -\\frac{G M m}{r^2} \\hat{r} \\] Where: \\(G = 6.674 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) \\(M\\) is Earth's mass ( \\(5.972 \\times 10^{24} \\ \\text{kg}\\) ) \\(r\\) is the distance from Earth's center The motion is governed by Newton\u2019s Second Law: \\(\\vec{F} = m \\vec{a}\\) 3. Initial Conditions Altitude : 800 km above Earth's surface Earth Radius : 6371 km \u2192 Initial radial distance: \\(R_0 = 7171 \\ \\text{km} = 7.171 \\times 10^6 \\ \\text{m}\\) Initial Velocities : from 5 km/s to 13 km/s in steps of 0.5 km/s Initial Position : on the right side of Earth (positive x-axis) Initial Velocity Direction : purely tangential (positive y-direction) 4. Python Simulation Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp G = 6.67430e-11 M = 5.972e24 R_earth = 6371e3 altitude = 800e3 r0 = R_earth + altitude t_span = (0, 20000) t_eval = np.linspace(t_span[0], t_span[1], 10000) def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] velocities_kms = np.arange(5, 13.5, 0.5) colors = plt.cm.viridis(np.linspace(0, 1, len(velocities_kms))) fig, ax = plt.subplots(figsize=(10, 10)) ax.add_patch(plt.Circle((0, 0), R_earth / 1e3, color='blue', label='Earth')) for i, v_kms in enumerate(velocities_kms): vx0 = 0 vy0 = v_kms * 1000 y0 = [r0, vx0, 0, vy0] sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) x = sol.y[0] y = sol.y[2] ax.plot(x / 1e3, y / 1e3, label=f'{v_kms:.1f} km/s', color=colors[i]) ax.plot(0, 0, 'ko', label='Center of Earth') ax.plot(r0 / 1e3, 0, 'yo', label='Start Point') ax.set_aspect('equal') ax.set_xlim(-20000, 20000) ax.set_ylim(-20000, 20000) ax.set_xlabel('X [km]') ax.set_ylabel('Y [km]') ax.set_title('Trajectories of Payloads Released at 800 km Altitude') ax.legend(loc='upper right') plt.grid(True) plt.show() 5. Observations & Analysis Velocities < 7.8 km/s : Suborbital trajectories \u2192 reentry. Around 7.8 km/s : Circular or low Earth orbits (LEO). Between 8\u201311.2 km/s : Elliptical or escape trajectories. > 11.2 km/s : Hyperbolic escape \u2014 the payload leaves Earth's gravitational field. 6. Real-World Applications Orbital insertion : Matching the orbital speed for satellite deployment. Escape missions : Reaching speeds above 11.2 km/s for moon or Mars missions. Controlled reentry : Lower speeds for deorbiting and returning safely. 7. Conclusion This simulation provides insights into how varying horizontal velocities affect the type of trajectory a payload follows. By understanding these outcomes, one can effectively plan orbital maneuvers, insertions, and escapes in real space missions. MyColab","title":"3\ufe0f"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3","text":"","title":"3\ufe0f"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-objective","text":"Analyze and simulate the trajectories of a payload released from a certain height (800 km above Earth's surface) with various initial horizontal velocities. Determine whether the resulting path is elliptical, parabolic, or hyperbolic , and relate these outcomes to space mission concepts like orbital insertion, reentry, or escape velocity .","title":"1. Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-physical-background","text":"We analyze the motion under Newton\u2019s Law of Universal Gravitation : \\[ \\vec{F}_g = -\\frac{G M m}{r^2} \\hat{r} \\] Where: \\(G = 6.674 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) \\(M\\) is Earth's mass ( \\(5.972 \\times 10^{24} \\ \\text{kg}\\) ) \\(r\\) is the distance from Earth's center The motion is governed by Newton\u2019s Second Law: \\(\\vec{F} = m \\vec{a}\\)","title":"2. Physical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-initial-conditions","text":"Altitude : 800 km above Earth's surface Earth Radius : 6371 km \u2192 Initial radial distance: \\(R_0 = 7171 \\ \\text{km} = 7.171 \\times 10^6 \\ \\text{m}\\) Initial Velocities : from 5 km/s to 13 km/s in steps of 0.5 km/s Initial Position : on the right side of Earth (positive x-axis) Initial Velocity Direction : purely tangential (positive y-direction)","title":"3. Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp G = 6.67430e-11 M = 5.972e24 R_earth = 6371e3 altitude = 800e3 r0 = R_earth + altitude t_span = (0, 20000) t_eval = np.linspace(t_span[0], t_span[1], 10000) def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] velocities_kms = np.arange(5, 13.5, 0.5) colors = plt.cm.viridis(np.linspace(0, 1, len(velocities_kms))) fig, ax = plt.subplots(figsize=(10, 10)) ax.add_patch(plt.Circle((0, 0), R_earth / 1e3, color='blue', label='Earth')) for i, v_kms in enumerate(velocities_kms): vx0 = 0 vy0 = v_kms * 1000 y0 = [r0, vx0, 0, vy0] sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) x = sol.y[0] y = sol.y[2] ax.plot(x / 1e3, y / 1e3, label=f'{v_kms:.1f} km/s', color=colors[i]) ax.plot(0, 0, 'ko', label='Center of Earth') ax.plot(r0 / 1e3, 0, 'yo', label='Start Point') ax.set_aspect('equal') ax.set_xlim(-20000, 20000) ax.set_ylim(-20000, 20000) ax.set_xlabel('X [km]') ax.set_ylabel('Y [km]') ax.set_title('Trajectories of Payloads Released at 800 km Altitude') ax.legend(loc='upper right') plt.grid(True) plt.show()","title":"4. Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-observations-analysis","text":"Velocities < 7.8 km/s : Suborbital trajectories \u2192 reentry. Around 7.8 km/s : Circular or low Earth orbits (LEO). Between 8\u201311.2 km/s : Elliptical or escape trajectories. > 11.2 km/s : Hyperbolic escape \u2014 the payload leaves Earth's gravitational field.","title":"5. Observations &amp; Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-real-world-applications","text":"Orbital insertion : Matching the orbital speed for satellite deployment. Escape missions : Reaching speeds above 11.2 km/s for moon or Mars missions. Controlled reentry : Lower speeds for deorbiting and returning safely.","title":"6. Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#7-conclusion","text":"This simulation provides insights into how varying horizontal velocities affect the type of trajectory a payload follows. By understanding these outcomes, one can effectively plan orbital maneuvers, insertions, and escapes in real space missions. MyColab","title":"7. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"1\ufe0f\u20e3 Problem 1: Interference Patterns on a Water Surface 1. Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when ripples from different points meet, forming distinctive interference patterns. Studying these patterns helps us: - Understand constructive and destructive interference - Visualize coherent wave interactions - Relate wave phase, distance, and geometry This task provides a hands-on simulation of superposed wave behaviors from multiple point sources arranged in polygonal formations. 2. Problem Statement You will analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon . 3. Steps select a Regular Polygon We'll use a regular pentagon (5 vertices) as the base case. Position the Sources Each wave source is placed at a vertex of the pentagon. Wave Equation for a Single Source The surface displacement from one point source is described by: \\[ z_i(x, y, t) = A \\cdot \\cos(k \\cdot r_i - \\omega \\cdot t + \\phi) \\] Where: - \\(A\\) : Amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number - \\(\\omega = 2\\pi f\\) : Angular frequency - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) : Distance from the i-th source - \\(\\phi\\) : Initial phase (0 for all sources) Superposition of Waves The total displacement is the sum: $$ z(x, y, t) = \\sum_{i=1}^{N} z_i(x, y, t) $$ 4. Interpretation Constructive Interference : Where waves from sources arrive in-phase \u2014 peaks reinforce each other. Destructive Interference : Where waves arrive out-of-phase \u2014 peaks cancel troughs. By placing sources at polygon vertices, symmetrical interference patterns emerge, showing how spatial wave arrangements shape the resulting surface. 5. Python Simulation Code import numpy as np import matplotlib.pyplot as plt from matplotlib import animation # Parameters A = 1 # Amplitude wavelength = 2 # Wavelength frequency = 1 # Frequency omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength phi = 0 # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Polygon: Regular Pentagon N = 5 radius = 5 sources = [(radius * np.cos(2*np.pi*i/N), radius * np.sin(2*np.pi*i/N)) for i in range(N)] # Superposition Function def wave_sum(t): Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid div by 0 Z += A * np.cos(k * r - omega * t + phi) return Z # Heatmap at fixed time t0 = 0 Z = wave_sum(t0) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Displacement') plt.title(\"Wave Interference Pattern (Pentagon Sources)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.show() # 3D Plot from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(\"3D Wave Interference\") ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Amplitude\") plt.show() # Animation (Optional GIF) fig, ax = plt.subplots() c = ax.contourf(X, Y, wave_sum(0), levels=100, cmap='RdBu') def animate(i): ax.clear() Z = wave_sum(i * 0.1) ax.contourf(X, Y, Z, levels=100, cmap='RdBu') ani = animation.FuncAnimation(fig, animate, frames=40, interval=100) ani.save('wave_interference.gif', writer='pillow') 6. Deliverables Code simulating interference from polygon-placed wave sources Heatmap and 3D plots illustrating constructive/destructive regions Animated GIF showing wave evolution over time Explanations of observed interference behaviors 7. Conclusion This simulation gives a visual and interactive insight into how waves from multiple sources interact through superposition . It emphasizes the importance of geometry in creating symmetrical or complex wave patterns and helps in understanding real-world wave phenomena such as sound interference, water ripples, and even quantum wavefunctions. MyColab","title":"1\ufe0f\u20e3"},{"location":"1%20Physics/3%20Waves/Problem_1/#1","text":"","title":"1\ufe0f\u20e3"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1-interference-patterns-on-a-water-surface","text":"","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when ripples from different points meet, forming distinctive interference patterns. Studying these patterns helps us: - Understand constructive and destructive interference - Visualize coherent wave interactions - Relate wave phase, distance, and geometry This task provides a hands-on simulation of superposed wave behaviors from multiple point sources arranged in polygonal formations.","title":"1. Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-problem-statement","text":"You will analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon .","title":"2. Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-steps","text":"select a Regular Polygon We'll use a regular pentagon (5 vertices) as the base case. Position the Sources Each wave source is placed at a vertex of the pentagon. Wave Equation for a Single Source The surface displacement from one point source is described by: \\[ z_i(x, y, t) = A \\cdot \\cos(k \\cdot r_i - \\omega \\cdot t + \\phi) \\] Where: - \\(A\\) : Amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number - \\(\\omega = 2\\pi f\\) : Angular frequency - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) : Distance from the i-th source - \\(\\phi\\) : Initial phase (0 for all sources) Superposition of Waves The total displacement is the sum: $$ z(x, y, t) = \\sum_{i=1}^{N} z_i(x, y, t) $$","title":"3. Steps"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-interpretation","text":"Constructive Interference : Where waves from sources arrive in-phase \u2014 peaks reinforce each other. Destructive Interference : Where waves arrive out-of-phase \u2014 peaks cancel troughs. By placing sources at polygon vertices, symmetrical interference patterns emerge, showing how spatial wave arrangements shape the resulting surface.","title":"4. Interpretation"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib import animation # Parameters A = 1 # Amplitude wavelength = 2 # Wavelength frequency = 1 # Frequency omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength phi = 0 # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Polygon: Regular Pentagon N = 5 radius = 5 sources = [(radius * np.cos(2*np.pi*i/N), radius * np.sin(2*np.pi*i/N)) for i in range(N)] # Superposition Function def wave_sum(t): Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid div by 0 Z += A * np.cos(k * r - omega * t + phi) return Z # Heatmap at fixed time t0 = 0 Z = wave_sum(t0) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, levels=100, cmap='RdBu') plt.colorbar(label='Displacement') plt.title(\"Wave Interference Pattern (Pentagon Sources)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.show() # 3D Plot from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(\"3D Wave Interference\") ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Amplitude\") plt.show() # Animation (Optional GIF) fig, ax = plt.subplots() c = ax.contourf(X, Y, wave_sum(0), levels=100, cmap='RdBu') def animate(i): ax.clear() Z = wave_sum(i * 0.1) ax.contourf(X, Y, Z, levels=100, cmap='RdBu') ani = animation.FuncAnimation(fig, animate, frames=40, interval=100) ani.save('wave_interference.gif', writer='pillow')","title":"5. Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#6-deliverables","text":"Code simulating interference from polygon-placed wave sources Heatmap and 3D plots illustrating constructive/destructive regions Animated GIF showing wave evolution over time Explanations of observed interference behaviors","title":"6. Deliverables"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-conclusion","text":"This simulation gives a visual and interactive insight into how waves from multiple sources interact through superposition . It emphasizes the importance of geometry in creating symmetrical or complex wave patterns and helps in understanding real-world wave phenomena such as sound interference, water ripples, and even quantum wavefunctions. MyColab","title":"7. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"1\ufe0f\u20e3 Electromagnetism Lorentz Force Simulation 1. Exploration of Applications The Lorentz force , given by: \\(\\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\\) is crucial in: Particle accelerators \u2013 where magnetic fields steer high-energy particles. Mass spectrometers \u2013 which use \\(\\vec{E}\\) and \\(\\vec{B}\\) to separate ions by mass. Plasma confinement \u2013 e.g. in tokamaks, where particles spiral due to strong magnetic fields. Astrophysics \u2013 charged particles in cosmic fields follow complex paths due to Lorentz force. Electric fields \\(\\vec{E}\\) accelerate charged particles, while magnetic fields \\(\\vec{B}\\) bend their trajectories perpendicularly to velocity. 2. Simulating Particle Motion We simulate a particle with: \\(q = 1 \\, \\text{C}\\) \\(m = 1 \\, \\text{g} = 0.001 \\, \\text{kg}\\) Scenarios: Uniform magnetic field only \u2013 expect circular motion. Uniform electric + magnetic field \u2013 expect helical or drift paths. Crossed \\(\\vec{E} \\perp \\vec{B}\\) \u2013 observe \\(\\vec{E} \\times \\vec{B}\\) drift. 3. Parameter Exploration Parameters to vary: Magnetic field \\(\\vec{B}\\) : magnitude and direction. Electric field \\(\\vec{E}\\) Initial velocity \\(\\vec{v}_0\\) Charge \\(q\\) and mass \\(m\\) Observe: Larmor radius : \\(r_L = \\frac{mv}{|qB|}\\) Drift velocity : \\(\\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) 4. Visualization Plot 2D (xy) and 3D trajectories Circle, spiral in z-direction, or other interesting paths Emphasize physical concepts (e.g., radius, velocity vector) Simulation Output: Python Simulation Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge [C] m = 0.001 # Mass [kg] dt = 1e-6 # Time step [s] steps = 10000 # Number of steps # Fields E = np.array([0.0, 0.0, 0.0]) # Uniform electric field [V/m] B = np.array([0.0, 0.0, 1.0]) # Uniform magnetic field [T] # Initial conditions v = np.array([10.0, 0.0, 0.0]) # Initial velocity [m/s] r = np.array([0.0, 0.0, 0.0]) # Initial position [m] # Trajectory trajectory = [r.copy()] # Euler method simulation for _ in range(steps): F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v = v + a * dt # Update velocity r = r + v * dt # Update position trajectory.append(r.copy()) trajectory = np.array(trajectory) # Plotting fig = plt.figure(figsize=(12,6)) # 2D projection ax1 = fig.add_subplot(121) ax1.plot(trajectory[:,0], trajectory[:,1]) ax1.set_title('2D Trajectory (XY)') ax1.set_xlabel('X (m)') ax1.set_ylabel('Y (m)') ax1.axis('equal') # 3D trajectory ax2 = fig.add_subplot(122, projection='3d') ax2.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax2.set_title('3D Trajectory') ax2.set_xlabel('X (m)') ax2.set_ylabel('Y (m)') ax2.set_zlabel('Z (m)') plt.tight_layout() plt.show() \ud83d\udd0d Discussion In a pure magnetic field , the particle undergoes circular motion in a plane perpendicular to \\(\\vec{B}\\) , due to the centripetal nature of the Lorentz force. Adding a parallel electric field induces spiral motion (helical path). In crossed fields , the particle drifts at velocity \\(\\vec{v}_d = \\vec{E} \\times \\vec{B}/B^2\\) \u2014 used in devices like velocity selectors. The Larmor radius and gyrofrequency can be observed directly in the plotted paths. MyColab","title":"1\ufe0f\u20e3"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1","text":"","title":"1\ufe0f\u20e3"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-simulation","text":"","title":"Electromagnetism Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"The Lorentz force , given by: \\(\\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B})\\) is crucial in: Particle accelerators \u2013 where magnetic fields steer high-energy particles. Mass spectrometers \u2013 which use \\(\\vec{E}\\) and \\(\\vec{B}\\) to separate ions by mass. Plasma confinement \u2013 e.g. in tokamaks, where particles spiral due to strong magnetic fields. Astrophysics \u2013 charged particles in cosmic fields follow complex paths due to Lorentz force. Electric fields \\(\\vec{E}\\) accelerate charged particles, while magnetic fields \\(\\vec{B}\\) bend their trajectories perpendicularly to velocity.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We simulate a particle with: \\(q = 1 \\, \\text{C}\\) \\(m = 1 \\, \\text{g} = 0.001 \\, \\text{kg}\\)","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenarios","text":"Uniform magnetic field only \u2013 expect circular motion. Uniform electric + magnetic field \u2013 expect helical or drift paths. Crossed \\(\\vec{E} \\perp \\vec{B}\\) \u2013 observe \\(\\vec{E} \\times \\vec{B}\\) drift.","title":"Scenarios:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"Parameters to vary: Magnetic field \\(\\vec{B}\\) : magnitude and direction. Electric field \\(\\vec{E}\\) Initial velocity \\(\\vec{v}_0\\) Charge \\(q\\) and mass \\(m\\) Observe: Larmor radius : \\(r_L = \\frac{mv}{|qB|}\\) Drift velocity : \\(\\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\)","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"Plot 2D (xy) and 3D trajectories Circle, spiral in z-direction, or other interesting paths Emphasize physical concepts (e.g., radius, velocity vector) Simulation Output:","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge [C] m = 0.001 # Mass [kg] dt = 1e-6 # Time step [s] steps = 10000 # Number of steps # Fields E = np.array([0.0, 0.0, 0.0]) # Uniform electric field [V/m] B = np.array([0.0, 0.0, 1.0]) # Uniform magnetic field [T] # Initial conditions v = np.array([10.0, 0.0, 0.0]) # Initial velocity [m/s] r = np.array([0.0, 0.0, 0.0]) # Initial position [m] # Trajectory trajectory = [r.copy()] # Euler method simulation for _ in range(steps): F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v = v + a * dt # Update velocity r = r + v * dt # Update position trajectory.append(r.copy()) trajectory = np.array(trajectory) # Plotting fig = plt.figure(figsize=(12,6)) # 2D projection ax1 = fig.add_subplot(121) ax1.plot(trajectory[:,0], trajectory[:,1]) ax1.set_title('2D Trajectory (XY)') ax1.set_xlabel('X (m)') ax1.set_ylabel('Y (m)') ax1.axis('equal') # 3D trajectory ax2 = fig.add_subplot(122, projection='3d') ax2.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax2.set_title('3D Trajectory') ax2.set_xlabel('X (m)') ax2.set_ylabel('Y (m)') ax2.set_zlabel('Z (m)') plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#discussion","text":"In a pure magnetic field , the particle undergoes circular motion in a plane perpendicular to \\(\\vec{B}\\) , due to the centripetal nature of the Lorentz force. Adding a parallel electric field induces spiral motion (helical path). In crossed fields , the particle drifts at velocity \\(\\vec{v}_d = \\vec{E} \\times \\vec{B}/B^2\\) \u2014 used in devices like velocity selectors. The Larmor radius and gyrofrequency can be observed directly in the plotted paths. MyColab","title":"\ud83d\udd0d Discussion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Equivalent Resistance Using Graph Theory 1. Problem Statement Goal: Compute the equivalent resistance between two nodes in a resistor network using graph theory. 2. Algorithm Explanation We treat the resistor network as an undirected weighted graph , where: Nodes represent junctions in the circuit. Edges represent resistors with weights equal to resistance values. The task is to find the equivalent resistance between two specific nodes (source and target). 3. Key Reduction Rules Series Reduction: If a node has exactly two neighbors and is not the source or target, we can collapse it: \\(R_eq = R1 + R2\\) Parallel Reduction: If multiple edges connect the same pair of nodes: \\(1/R_eq = sum(1/Ri)\\) General Case: Use Kirchhoff's laws and linear algebra to solve for node potentials and derive current, if needed. But for simplification and automation, we reduce the graph step by step using rules above. 4. Python Implementation (with NetworkX) import networkx as nx import matplotlib.pyplot as plt def combine_parallel_edges(G): to_add = [] to_remove = [] for u, v in G.edges(): all_edges = G.get_edge_data(u, v) if all_edges and len(all_edges) > 1: total_inv = sum(1 / d['resistance'] for d in all_edges.values()) req = 1 / total_inv to_add.append((u, v, {'resistance': req})) to_remove.extend((u, v, k) for k in all_edges) for u, v, k in to_remove: G.remove_edge(u, v, key=k) for u, v, data in to_add: G.add_edge(u, v, resistance=data['resistance']) def reduce_series_nodes(G, source, target): changed = True while changed: changed = False for node in list(G.nodes()): if node in [source, target]: continue neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if G.number_of_edges(u, node) == 1 and G.number_of_edges(node, v) == 1: r1 = G[u][node][0]['resistance'] r2 = G[node][v][0]['resistance'] G.add_edge(u, v, resistance=r1 + r2) G.remove_node(node) changed = True break def calculate_equivalent_resistance(G, source, target): combine_parallel_edges(G) reduce_series_nodes(G, source, target) if G.has_edge(source, target): return G[source][target][0]['resistance'] else: return \"Could not reduce the circuit to a single resistance.\" def draw_circuit(G): pos = nx.spring_layout(G, seed=42) edge_labels = {(u, v): f\"{d['resistance']}\u03a9\" for u, v, d in G.edges(data=True)} plt.figure(figsize=(6, 4)) nx.draw(G, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=800, font_size=10) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=9) plt.title(\"Circuit Graph\") plt.axis('off') plt.show() G = nx.MultiGraph() G.add_edge('A', 'B', resistance=5) G.add_edge('B', 'C', resistance=10) G.add_edge('C', 'D', resistance=15) G.add_edge('A', 'D', resistance=30) draw_circuit(G) print(\"Equivalent resistance from A to D:\") print(calculate_equivalent_resistance(G, 'A', 'D')) 5. Example Scenarios Example 1 \u2013 Series Only \\(A --(5\u03a9)-- B --(10\u03a9)-- C\\) Result: \\( R_eq = 15\u03a9 \\) Example 2 \u2013 Parallel Only $ A --(10\u03a9)-- B A --(20\u03a9)-- B $ Result: \\(R_eq = 1 / (1/10 + 1/20) = 6.67\u03a9\\) Example 3 \u2013 Mixed (like in code above) $ A --(5\u03a9)-- B --(10\u03a9)-- C --(15\u03a9)-- D A ----------------------------- D (30\u03a9) $ Combined: \\(R_(parallel) = 1 / (1/30 + 1/30) = 15\u03a9\\) Equivalent resistance from A to D: 30\u03a9 6. Efficiency & Improvements Time complexity: Each reduction (series or parallel) is linear with respect to number of nodes/edges. Can be improved with: Better pattern detection for mesh loops (needs Kirchhoff's matrix method). Symbolic computation (e.g. using sympy ) for algebraic analysis. MyColab","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-problem-statement","text":"Goal: Compute the equivalent resistance between two nodes in a resistor network using graph theory.","title":"1. Problem Statement"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-algorithm-explanation","text":"We treat the resistor network as an undirected weighted graph , where: Nodes represent junctions in the circuit. Edges represent resistors with weights equal to resistance values. The task is to find the equivalent resistance between two specific nodes (source and target).","title":"2. Algorithm Explanation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-key-reduction-rules","text":"Series Reduction: If a node has exactly two neighbors and is not the source or target, we can collapse it: \\(R_eq = R1 + R2\\) Parallel Reduction: If multiple edges connect the same pair of nodes: \\(1/R_eq = sum(1/Ri)\\) General Case: Use Kirchhoff's laws and linear algebra to solve for node potentials and derive current, if needed. But for simplification and automation, we reduce the graph step by step using rules above.","title":"3. Key Reduction Rules"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-python-implementation-with-networkx","text":"import networkx as nx import matplotlib.pyplot as plt def combine_parallel_edges(G): to_add = [] to_remove = [] for u, v in G.edges(): all_edges = G.get_edge_data(u, v) if all_edges and len(all_edges) > 1: total_inv = sum(1 / d['resistance'] for d in all_edges.values()) req = 1 / total_inv to_add.append((u, v, {'resistance': req})) to_remove.extend((u, v, k) for k in all_edges) for u, v, k in to_remove: G.remove_edge(u, v, key=k) for u, v, data in to_add: G.add_edge(u, v, resistance=data['resistance']) def reduce_series_nodes(G, source, target): changed = True while changed: changed = False for node in list(G.nodes()): if node in [source, target]: continue neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if G.number_of_edges(u, node) == 1 and G.number_of_edges(node, v) == 1: r1 = G[u][node][0]['resistance'] r2 = G[node][v][0]['resistance'] G.add_edge(u, v, resistance=r1 + r2) G.remove_node(node) changed = True break def calculate_equivalent_resistance(G, source, target): combine_parallel_edges(G) reduce_series_nodes(G, source, target) if G.has_edge(source, target): return G[source][target][0]['resistance'] else: return \"Could not reduce the circuit to a single resistance.\" def draw_circuit(G): pos = nx.spring_layout(G, seed=42) edge_labels = {(u, v): f\"{d['resistance']}\u03a9\" for u, v, d in G.edges(data=True)} plt.figure(figsize=(6, 4)) nx.draw(G, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=800, font_size=10) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=9) plt.title(\"Circuit Graph\") plt.axis('off') plt.show() G = nx.MultiGraph() G.add_edge('A', 'B', resistance=5) G.add_edge('B', 'C', resistance=10) G.add_edge('C', 'D', resistance=15) G.add_edge('A', 'D', resistance=30) draw_circuit(G) print(\"Equivalent resistance from A to D:\") print(calculate_equivalent_resistance(G, 'A', 'D'))","title":"4. Python Implementation (with NetworkX)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-example-scenarios","text":"","title":"5. Example Scenarios"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-series-only","text":"\\(A --(5\u03a9)-- B --(10\u03a9)-- C\\) Result: \\( R_eq = 15\u03a9 \\)","title":"Example 1 \u2013 Series Only"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel-only","text":"$ A --(10\u03a9)-- B A --(20\u03a9)-- B $ Result: \\(R_eq = 1 / (1/10 + 1/20) = 6.67\u03a9\\)","title":"Example 2 \u2013 Parallel Only"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-mixed-like-in-code-above","text":"$ A --(5\u03a9)-- B --(10\u03a9)-- C --(15\u03a9)-- D A ----------------------------- D (30\u03a9) $ Combined: \\(R_(parallel) = 1 / (1/30 + 1/30) = 15\u03a9\\) Equivalent resistance from A to D: 30\u03a9","title":"Example 3 \u2013 Mixed (like in code above)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-efficiency-improvements","text":"Time complexity: Each reduction (series or parallel) is linear with respect to number of nodes/edges. Can be improved with: Better pattern detection for mesh loops (needs Kirchhoff's matrix method). Symbolic computation (e.g. using sympy ) for algebraic analysis. MyColab","title":"6. Efficiency &amp; Improvements"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"1\ufe0f\u20e3 Exploring the Central Limit Theorem through Simulations 1. Motivation The Central Limit Theorem (CLT) states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases, regardless of the shape of the population distribution. This principle underpins many statistical methods and is fundamental in real-world applications. 2. Simulating Sampling Distributions We'll explore three types of population distributions: Uniform distribution : Evenly distributed values. Exponential distribution : Skewed, non-symmetric. Binomial distribution : Discrete with two outcomes. Each distribution is simulated using a large population of 100,000 elements. 3. Sampling and Visualization For each distribution, we take repeated random samples with the following sizes: 5, 10, 30, and 50 For each sample size, we repeat sampling 1000 times and calculate the sample mean to form the sampling distribution . 4. Parameter Exploration We explore: How quickly the sampling distribution approaches normality as the sample size increases. How the population\u2019s variance affects the spread of the sample mean distribution. 5. Practical Applications of CLT Estimating population parameters : Even if a population is not normally distributed, large enough samples allow valid inference using normal theory. Quality control : In manufacturing, averages of product measurements are used for control charts. Financial modeling : Portfolio returns often use the normal approximation via CLT. 6. Python Code for Simulation and Visualization import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Seaborn style for better visuals sns.set(style=\"whitegrid\") # Parameters sample_sizes = [5, 10, 30, 50] n_simulations = 1000 population_size = 100000 # Distributions to explore distributions = { \"Uniform\": np.random.uniform(0, 1, population_size), \"Exponential\": np.random.exponential(1, population_size), \"Binomial\": np.random.binomial(n=10, p=0.5, size=population_size) } # Plotting for dist_name, population in distributions.items(): plt.figure(figsize=(16, 10)) for i, n in enumerate(sample_sizes, 1): sample_means = [] for _ in range(n_simulations): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) plt.subplot(2, 2, i) sns.histplot(sample_means, bins=30, kde=True, color=\"skyblue\") plt.title(f\"{dist_name} Distribution - Sample Size {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distribution of the Mean - {dist_name}\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() 7. Discussion & Insights Uniform Distribution : Converges quickly to normality even with small sample sizes. Exponential Distribution : Highly skewed at the population level but still shows convergence around sample size 30+. Binomial Distribution : Initially discrete, but sampling smooths out the mean distribution, approaching normality. Effect of Population Variance The spread (standard deviation) of the sample mean decreases with increasing sample size. This is predicted by: \\[ \\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}} \\] This highlights how variance impacts the precision of sample estimates. Conclusion This simulation-driven approach demonstrates the power and universality of the Central Limit Theorem . Even for non-normal populations, the distribution of the sample mean becomes approximately normal as sample size grows. This supports many practical applications in statistics, quality control, finance, and science. MyColab","title":"1\ufe0f\u20e3"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1","text":"","title":"1\ufe0f\u20e3"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-motivation","text":"The Central Limit Theorem (CLT) states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases, regardless of the shape of the population distribution. This principle underpins many statistical methods and is fundamental in real-world applications.","title":"1. Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-simulating-sampling-distributions","text":"We'll explore three types of population distributions: Uniform distribution : Evenly distributed values. Exponential distribution : Skewed, non-symmetric. Binomial distribution : Discrete with two outcomes. Each distribution is simulated using a large population of 100,000 elements.","title":"2. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-sampling-and-visualization","text":"For each distribution, we take repeated random samples with the following sizes: 5, 10, 30, and 50 For each sample size, we repeat sampling 1000 times and calculate the sample mean to form the sampling distribution .","title":"3. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-parameter-exploration","text":"We explore: How quickly the sampling distribution approaches normality as the sample size increases. How the population\u2019s variance affects the spread of the sample mean distribution.","title":"4. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-practical-applications-of-clt","text":"Estimating population parameters : Even if a population is not normally distributed, large enough samples allow valid inference using normal theory. Quality control : In manufacturing, averages of product measurements are used for control charts. Financial modeling : Portfolio returns often use the normal approximation via CLT.","title":"5. Practical Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-python-code-for-simulation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Seaborn style for better visuals sns.set(style=\"whitegrid\") # Parameters sample_sizes = [5, 10, 30, 50] n_simulations = 1000 population_size = 100000 # Distributions to explore distributions = { \"Uniform\": np.random.uniform(0, 1, population_size), \"Exponential\": np.random.exponential(1, population_size), \"Binomial\": np.random.binomial(n=10, p=0.5, size=population_size) } # Plotting for dist_name, population in distributions.items(): plt.figure(figsize=(16, 10)) for i, n in enumerate(sample_sizes, 1): sample_means = [] for _ in range(n_simulations): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) plt.subplot(2, 2, i) sns.histplot(sample_means, bins=30, kde=True, color=\"skyblue\") plt.title(f\"{dist_name} Distribution - Sample Size {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distribution of the Mean - {dist_name}\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show()","title":"6. Python Code for Simulation and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#7-discussion-insights","text":"Uniform Distribution : Converges quickly to normality even with small sample sizes. Exponential Distribution : Highly skewed at the population level but still shows convergence around sample size 30+. Binomial Distribution : Initially discrete, but sampling smooths out the mean distribution, approaching normality.","title":"7. Discussion &amp; Insights"},{"location":"1%20Physics/6%20Statistics/Problem_1/#effect-of-population-variance","text":"The spread (standard deviation) of the sample mean decreases with increasing sample size. This is predicted by: \\[ \\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}} \\] This highlights how variance impacts the precision of sample estimates.","title":"Effect of Population Variance"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"This simulation-driven approach demonstrates the power and universality of the Central Limit Theorem . Even for non-normal populations, the distribution of the sample mean becomes approximately normal as sample size grows. This supports many practical applications in statistics, quality control, finance, and science. MyColab","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"2\ufe0f\u20e3 Estimating \u03c0 Using Monte Carlo Methods 1. Problem Statement Monte Carlo simulations use randomness to solve mathematical problems. One of the most elegant uses is estimating the value of \u03c0. We will explore two approaches: Estimating \u03c0 using a circle. Estimating \u03c0 using Buffon\u2019s Needle experiment. 2. Part 1: Estimating \u03c0 Using a Circle 1. Theoretical Foundation We simulate random points in a square that bounds a unit circle (radius = 1). The area of the circle is $ \\pi r^2 $, and the square\u2019s area is $ (2r)^2 = 4 $. The ratio gives: $ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\Rightarrow \\pi \\approx 4 \\cdot \\frac{\\text{Points inside}}{\\text{Total points}} $ 2. Simulation We generate random points \\((x, y)\\) in the square \\([-1, 1] \\times [-1, 1]\\) , then count how many fall inside the circle using the condition: $ x^2 + y^2 \\leq 1 $ 3. Python Implementation import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.title(f\"Monte Carlo \u03c0 Estimate: {pi_estimate:.6f} (n={n_points})\") plt.gca().set_aspect('equal') plt.legend() plt.show() return pi_estimate 4. Visualization 5. Analysis As the number of points increases, the estimate becomes more accurate. Convergence rate is approximately $ \\mathcal{O}(1/\\sqrt{N}) $. Simple to implement, but requires many iterations for high accuracy. Part 2: Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Foundation Buffon\u2019s Needle problem estimates \u03c0 from the probability of a needle crossing lines spaced at distance $ d $, using a needle of length $ l \\leq d $. $ P = \\frac{2l}{\\pi d} \\Rightarrow \\pi \\approx \\frac{2l \\cdot N}{d \\cdot H} $ Where: - $ N $: total needle drops - $ H $: number of hits (crossings) 2. Simulation A needle crosses a line if: $ \\frac{l}{2} \\cdot \\sin(\\theta) \\geq \\text{distance from center to nearest line} $ 3. Python Implementation def buffon_needle(n_drops, l=1.0, d=2.0): hits = 0 xs, ys, angles = [], [], [] for _ in range(n_drops): center_y = np.random.uniform(0, d/2) theta = np.random.uniform(0, np.pi / 2) if (l / 2) * np.sin(theta) >= center_y: hits += 1 xs.append(center_y) ys.append(theta) angles.append(theta) pi_estimate = (2 * l * n_drops) / (d * hits) if hits != 0 else 0 plt.figure(figsize=(6, 6)) for i in range(n_drops): y0 = xs[i] angle = angles[i] x_start = 0 x_end = np.cos(angle) y_start = y0 y_end = y0 + np.sin(angle) color = 'green' if (l / 2) * np.sin(angle) >= y0 else 'gray' plt.plot([x_start, x_end], [y_start, y_end], color=color, alpha=0.6) for i in range(5): plt.axhline(i * d / 4, color='black', linestyle='--', linewidth=0.5) plt.title(f\"Buffon's Needle \u03c0 Estimate: {pi_estimate:.6f} (n={n_drops})\") plt.xlim(0, 1) plt.ylim(0, d/2) plt.show() return pi_estimate 4. Visualization 5. Analysis Buffon\u2019s method converges slowly compared to the circle method. Physically inspired and useful for demonstrating probabilistic geometry. Useful for introducing students to the intersection of geometry and probability. Convergence Analysis To compare both methods: Run multiple trials (e.g., with 100, 1,000, 10,000, 100,000 iterations). Track estimated \u03c0 values. Plot error vs. number of iterations. Insert table or plot comparing convergence of both methods here. \u2705 Conclusion Circle-based Monte Carlo is more accurate per iteration. Buffon\u2019s Needle is slower but more interesting geometrically. Both show how randomness and geometry can estimate fundamental constants. MyColab","title":"2\ufe0f\u20e3"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2","text":"","title":"2\ufe0f\u20e3"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-problem-statement","text":"Monte Carlo simulations use randomness to solve mathematical problems. One of the most elegant uses is estimating the value of \u03c0. We will explore two approaches: Estimating \u03c0 using a circle. Estimating \u03c0 using Buffon\u2019s Needle experiment.","title":"1. Problem Statement"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-part-1-estimating-using-a-circle","text":"","title":"2. Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"We simulate random points in a square that bounds a unit circle (radius = 1). The area of the circle is $ \\pi r^2 $, and the square\u2019s area is $ (2r)^2 = 4 $. The ratio gives: $ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\Rightarrow \\pi \\approx 4 \\cdot \\frac{\\text{Points inside}}{\\text{Total points}} $","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"We generate random points \\((x, y)\\) in the square \\([-1, 1] \\times [-1, 1]\\) , then count how many fall inside the circle using the condition: $ x^2 + y^2 \\leq 1 $","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.title(f\"Monte Carlo \u03c0 Estimate: {pi_estimate:.6f} (n={n_points})\") plt.gca().set_aspect('equal') plt.legend() plt.show() return pi_estimate","title":"3. Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-visualization","text":"","title":"4. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#5-analysis","text":"As the number of points increases, the estimate becomes more accurate. Convergence rate is approximately $ \\mathcal{O}(1/\\sqrt{N}) $. Simple to implement, but requires many iterations for high accuracy.","title":"5. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Buffon\u2019s Needle problem estimates \u03c0 from the probability of a needle crossing lines spaced at distance $ d $, using a needle of length $ l \\leq d $. $ P = \\frac{2l}{\\pi d} \\Rightarrow \\pi \\approx \\frac{2l \\cdot N}{d \\cdot H} $ Where: - $ N $: total needle drops - $ H $: number of hits (crossings)","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"A needle crosses a line if: $ \\frac{l}{2} \\cdot \\sin(\\theta) \\geq \\text{distance from center to nearest line} $","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-python-implementation_1","text":"def buffon_needle(n_drops, l=1.0, d=2.0): hits = 0 xs, ys, angles = [], [], [] for _ in range(n_drops): center_y = np.random.uniform(0, d/2) theta = np.random.uniform(0, np.pi / 2) if (l / 2) * np.sin(theta) >= center_y: hits += 1 xs.append(center_y) ys.append(theta) angles.append(theta) pi_estimate = (2 * l * n_drops) / (d * hits) if hits != 0 else 0 plt.figure(figsize=(6, 6)) for i in range(n_drops): y0 = xs[i] angle = angles[i] x_start = 0 x_end = np.cos(angle) y_start = y0 y_end = y0 + np.sin(angle) color = 'green' if (l / 2) * np.sin(angle) >= y0 else 'gray' plt.plot([x_start, x_end], [y_start, y_end], color=color, alpha=0.6) for i in range(5): plt.axhline(i * d / 4, color='black', linestyle='--', linewidth=0.5) plt.title(f\"Buffon's Needle \u03c0 Estimate: {pi_estimate:.6f} (n={n_drops})\") plt.xlim(0, 1) plt.ylim(0, d/2) plt.show() return pi_estimate","title":"3. Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-visualization_1","text":"","title":"4. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#5-analysis_1","text":"Buffon\u2019s method converges slowly compared to the circle method. Physically inspired and useful for demonstrating probabilistic geometry. Useful for introducing students to the intersection of geometry and probability.","title":"5. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"To compare both methods: Run multiple trials (e.g., with 100, 1,000, 10,000, 100,000 iterations). Track estimated \u03c0 values. Plot error vs. number of iterations. Insert table or plot comparing convergence of both methods here.","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Circle-based Monte Carlo is more accurate per iteration. Buffon\u2019s Needle is slower but more interesting geometrically. Both show how randomness and geometry can estimate fundamental constants. MyColab","title":"\u2705 Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}